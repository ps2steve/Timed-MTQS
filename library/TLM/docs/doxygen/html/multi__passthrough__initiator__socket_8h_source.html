<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TLM-2.0: include/tlm/tlm_utils/multi_passthrough_initiator_socket.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>include/tlm/tlm_utils/multi_passthrough_initiator_socket.h</h1><a href="multi__passthrough__initiator__socket_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  The following code is derived, directly or indirectly, from the SystemC</span>
<a name="l00004"></a>00004 <span class="comment">  source code Copyright (c) 1996-2008 by all Contributors.</span>
<a name="l00005"></a>00005 <span class="comment">  All Rights reserved.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">  The contents of this file are subject to the restrictions and limitations</span>
<a name="l00008"></a>00008 <span class="comment">  set forth in the SystemC Open Source License Version 3.0 (the "License");</span>
<a name="l00009"></a>00009 <span class="comment">  You may not use this file except in compliance with such restrictions and</span>
<a name="l00010"></a>00010 <span class="comment">  limitations. You may obtain instructions on how to receive a copy of the</span>
<a name="l00011"></a>00011 <span class="comment">  License at http://www.systemc.org/. Software distributed by Contributors</span>
<a name="l00012"></a>00012 <span class="comment">  under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF</span>
<a name="l00013"></a>00013 <span class="comment">  ANY KIND, either express or implied. See the License for the specific</span>
<a name="l00014"></a>00014 <span class="comment">  language governing rights and limitations under the License.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment"> *****************************************************************************/</span>
<a name="l00017"></a>00017 <span class="preprocessor">#ifndef __MULTI_PASSTHROUGH_INITIATOR_SOCKET_H__</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span><span class="preprocessor">#define __MULTI_PASSTHROUGH_INITIATOR_SOCKET_H__</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span>
<a name="l00020"></a>00020 <span class="preprocessor">#include "<a class="code" href="multi__socket__bases_8h.html">multi_socket_bases.h</a>"</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="keyword">namespace </span>tlm_utils {
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="comment">/*</span>
<a name="l00025"></a>00025 <span class="comment">This class implements a trivial multi initiator socket.</span>
<a name="l00026"></a>00026 <span class="comment">The triviality refers to the fact that the socket does not</span>
<a name="l00027"></a>00027 <span class="comment">do blocking to non-blocking or non-blocking to blocking conversions.</span>
<a name="l00028"></a>00028 <span class="comment"></span>
<a name="l00029"></a>00029 <span class="comment">It allows to connect multiple targets to this socket.</span>
<a name="l00030"></a>00030 <span class="comment">The user has to register callbacks for the bw interface methods</span>
<a name="l00031"></a>00031 <span class="comment">he likes to use. The callbacks are basically equal to the bw interface</span>
<a name="l00032"></a>00032 <span class="comment">methods but carry an additional integer that indicates to which</span>
<a name="l00033"></a>00033 <span class="comment">index of this socket the calling target is connected.</span>
<a name="l00034"></a>00034 <span class="comment">*/</span>
<a name="l00035"></a>00035 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> MODULE,
<a name="l00036"></a>00036           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> BUSWIDTH = 32,
<a name="l00037"></a>00037           <span class="keyword">typename</span> TYPES = <a class="code" href="structtlm_1_1tlm__base__protocol__types.html">tlm::tlm_base_protocol_types</a>,
<a name="l00038"></a>00038           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N=0
<a name="l00039"></a>00039 <span class="preprocessor">#if !(defined SYSTEMC_VERSION &amp; SYSTEMC_VERSION &lt;= 20050714)</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>          ,sc_core::sc_port_policy POL = sc_core::SC_ONE_OR_MORE_BOUND
<a name="l00041"></a>00041 <span class="preprocessor">#endif</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>          &gt;
<a name="l00043"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html">00043</a> <span class="keyword">class </span><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html">multi_passthrough_initiator_socket</a>: <span class="keyword">public</span> <a class="code" href="classtlm__utils_1_1multi__init__base.html">multi_init_base</a>&lt; BUSWIDTH, 
<a name="l00044"></a>00044                                                         TYPES,
<a name="l00045"></a>00045                                                         N
<a name="l00046"></a>00046 #if !(defined SYSTEMC_VERSION &amp; SYSTEMC_VERSION &lt;= 20050714)
<a name="l00047"></a>00047                                                         ,POL
<a name="l00048"></a>00048 #endif
<a name="l00049"></a>00049                                                         &gt;
<a name="l00050"></a>00050 {
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 public:
<a name="l00053"></a>00053 
<a name="l00054"></a>00054   <span class="comment">//typedefs</span>
<a name="l00055"></a>00055   <span class="comment">//  tlm 2.0 types for nb_transport</span>
<a name="l00056"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#e79de77c20d9b10cf2f92103b6350f62">00056</a>   typedef typename TYPES::tlm_payload_type              transaction_type;
<a name="l00057"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#7b6f94171743062801eca26edde24efc">00057</a>   typedef typename TYPES::tlm_phase_type                phase_type;  
<a name="l00058"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#08b034d03da58f38e132f501d320406d">00058</a>   typedef tlm::tlm_sync_enum                            sync_enum_type;
<a name="l00059"></a>00059   
<a name="l00060"></a>00060   <span class="comment">//  typedefs to keep the fn ptr notations short</span>
<a name="l00061"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#9badafae6c38735558b937d4ed197179">00061</a>   typedef sync_enum_type (MODULE::*nb_cb)(int,
<a name="l00062"></a>00062                                          transaction_type&amp;,
<a name="l00063"></a>00063                                          phase_type&amp;,
<a name="l00064"></a>00064                                          sc_core::sc_time&amp;);
<a name="l00065"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#0191077f22bab9c26316c137a5ede0aa">00065</a>   typedef void (MODULE::*dmi_cb)(int, sc_dt::uint64, sc_dt::uint64);
<a name="l00066"></a>00066 
<a name="l00067"></a>00067   typedef multi_init_base&lt;BUSWIDTH, 
<a name="l00068"></a>00068                         TYPES,
<a name="l00069"></a>00069                         N
<a name="l00070"></a>00070 #if !(defined SYSTEMC_VERSION &amp; SYSTEMC_VERSION &lt;= 20050714)
<a name="l00071"></a>00071                         ,POL
<a name="l00072"></a>00072 #endif
<a name="l00073"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#f40922fe7533a7c87129c2cafb886c4e">00073</a>                         &gt; base_type;
<a name="l00074"></a>00074 
<a name="l00075"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#412be3159f765aab119920bdf9dbd8b4">00075</a>   typedef typename base_type::base_target_socket_type base_target_socket_type;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077   <span class="comment">//CTOR</span>
<a name="l00078"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#b2f594038777093c116b8bf9dfb1666b">00078</a>   multi_passthrough_initiator_socket()
<a name="l00079"></a>00079       : base_type(sc_core::sc_gen_unique_name("multi_passthrough_initiator_socket"))
<a name="l00080"></a>00080       , m_hierarch_bind(0)
<a name="l00081"></a>00081       , m_beoe_disabled(false)
<a name="l00082"></a>00082       , m_dummy(42)
<a name="l00083"></a>00083   {
<a name="l00084"></a>00084   }
<a name="l00085"></a>00085 
<a name="l00086"></a>00086   <span class="comment">//CTOR</span>
<a name="l00087"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#25a32eb1ecb45740054faf167eaeb1e5">00087</a>   multi_passthrough_initiator_socket(const char* name)
<a name="l00088"></a>00088       : base_type(name)
<a name="l00089"></a>00089       , m_hierarch_bind(0)
<a name="l00090"></a>00090       , m_beoe_disabled(false)
<a name="l00091"></a>00091       , m_dummy(42)
<a name="l00092"></a>00092   {
<a name="l00093"></a>00093   }
<a name="l00094"></a>00094 
<a name="l00095"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#1b1df1846b3b2ee6d3ca96712452ea06">00095</a>   ~multi_passthrough_initiator_socket(){
<a name="l00096"></a>00096     <span class="comment">//clean up everything allocated by 'new'</span>
<a name="l00097"></a>00097     for (unsigned int i=0; i&lt;m_binders.size(); i++) delete m_binders[i];
<a name="l00098"></a>00098   }
<a name="l00099"></a>00099   
<a name="l00100"></a>00100   <span class="comment">//simple helpers for warnings an errors to shorten in code notation</span>
<a name="l00101"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#34739a9de3aab6570e4b0c30dbd45d69">00101</a>   void display_warning(const std::string&amp; text){
<a name="l00102"></a>00102     std::stringstream s;
<a name="l00103"></a>00103     s&lt;&lt;"WARNING in instance "&lt;&lt;base_type::name()&lt;&lt;": "&lt;&lt;text;
<a name="l00104"></a>00104     SC_REPORT_WARNING("/OSCI_TLM-2/multi_socket", s.str().c_str());
<a name="l00105"></a>00105   }
<a name="l00106"></a>00106 
<a name="l00107"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#a4ced17c44352261d1e80b95422b7acc">00107</a>   void display_error(const std::string&amp; text){
<a name="l00108"></a>00108     std::stringstream s;
<a name="l00109"></a>00109     s&lt;&lt;"ERROR in instance "&lt;&lt;base_type::name()&lt;&lt;": "&lt;&lt;text;
<a name="l00110"></a>00110     SC_REPORT_ERROR("/OSCI_TLM-2/multi_socket", s.str().c_str());
<a name="l00111"></a>00111   }
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 
<a name="l00114"></a>00114   <span class="comment">//register callback for nb transport of bw interface</span>
<a name="l00115"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#a71818a86f768d9e55c5a7e20f1cdb63">00115</a>   void register_nb_transport_bw(MODULE* mod,
<a name="l00116"></a>00116                               sync_enum_type (MODULE::*cb)(int,
<a name="l00117"></a>00117                                                            transaction_type&amp;,
<a name="l00118"></a>00118                                                            phase_type&amp;,
<a name="l00119"></a>00119                                                            sc_core::sc_time&amp;))
<a name="l00120"></a>00120   {
<a name="l00121"></a>00121     <span class="comment">//warn if there already is a callback</span>
<a name="l00122"></a>00122     if (!m_nb_f.empty()){
<a name="l00123"></a>00123       display_warning("NBTransport_bw callback already registered.");
<a name="l00124"></a>00124       return;
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126     
<a name="l00127"></a>00127     <span class="comment">//set the functor</span>
<a name="l00128"></a>00128     m_nb_f.set_function(mod, cb);
<a name="l00129"></a>00129   }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131   <span class="comment">//register callback for dmi function of bw interface</span>
<a name="l00132"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#cb90f0f47ec64a9b3a47bd9c90f6884c">00132</a>   void register_invalidate_direct_mem_ptr(MODULE* mod,
<a name="l00133"></a>00133                              void (MODULE::*cb)(int, sc_dt::uint64, sc_dt::uint64))
<a name="l00134"></a>00134   {
<a name="l00135"></a>00135     <span class="comment">//warn if there already is a callback</span>
<a name="l00136"></a>00136     if (!m_dmi_f.empty()){
<a name="l00137"></a>00137       display_warning("InvalidateDMI callback already registered.");
<a name="l00138"></a>00138       return;
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140     
<a name="l00141"></a>00141     <span class="comment">//set the functor</span>
<a name="l00142"></a>00142     m_dmi_f.set_function(mod, cb);
<a name="l00143"></a>00143   }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145   <span class="comment">//Override virtual functions of the tlm_initiator_socket:</span>
<a name="l00146"></a>00146   <span class="comment">// this function is called whenever an sc_port (as part of a target socket)</span>
<a name="l00147"></a>00147   <span class="comment">//  wants to bind to the export of the underlying tlm_initiator_socket</span>
<a name="l00148"></a>00148   <span class="comment">//At this time a callback binder is created an returned to the sc_port</span>
<a name="l00149"></a>00149   <span class="comment">// of the target socket, so that it binds to the callback binder</span>
<a name="l00150"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#9d4d6d139eacaa8ad6acf87ae3889115">00150</a>   virtual tlm::tlm_bw_transport_if&lt;TYPES&gt;&amp; get_base_interface()
<a name="l00151"></a>00151   {
<a name="l00152"></a>00152     m_binders.push_back(new callback_binder_bw&lt;TYPES&gt;(m_binders.size()));
<a name="l00153"></a>00153     return *m_binders[m_binders.size()-1];
<a name="l00154"></a>00154   }
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   <span class="comment">//Override virtual functions of the tlm_initiator_socket:</span>
<a name="l00157"></a>00157   <span class="comment">// this function is called whenever an sc_export (as part of a initiator socket)</span>
<a name="l00158"></a>00158   <span class="comment">//  wants to bind to the export of the underlying tlm_initiator_socket</span>
<a name="l00159"></a>00159   <span class="comment">//   i.e. a hierarchical bind takes place</span>
<a name="l00160"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#35beeda7838ceda497f6717549211d19">00160</a>   virtual sc_core::sc_export&lt;tlm::tlm_bw_transport_if&lt;TYPES&gt; &gt;&amp; get_base_export()
<a name="l00161"></a>00161   {
<a name="l00162"></a>00162     if (!m_beoe_disabled) <span class="comment">//we are not bound hierarchically</span>
<a name="l00163"></a>00163       base_type::m_export.bind(m_dummy);  <span class="comment">//so we bind the dummy to avoid a SystemC error</span>
<a name="l00164"></a>00164     return base_type::m_export; <span class="comment">//and then return our own export so that the hierarchical binding is set up properly</span>
<a name="l00165"></a>00165   }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167   <span class="comment">//bind against a target socket</span>
<a name="l00168"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#2b1c632fdc796b1b87589a960b096e1c">00168</a>   void bind(base_target_socket_type&amp; s)
<a name="l00169"></a>00169   {
<a name="l00170"></a>00170     <span class="comment">//error if this socket is already bound hierarchically</span>
<a name="l00171"></a>00171     if (m_hierarch_bind)
<a name="l00172"></a>00172       display_error("Already hierarchically bound.");     
<a name="l00173"></a>00173        
<a name="l00174"></a>00174     base_type::bind(s); <span class="comment">//satisfy systemC, leads to a call to get_base_interface()</span>
<a name="l00175"></a>00175     
<a name="l00176"></a>00176     <span class="comment">//try to cast the target socket into a fw interface</span>
<a name="l00177"></a>00177     sc_core::sc_export&lt;tlm::tlm_fw_transport_if&lt;TYPES&gt; &gt;* p_ex_s=dynamic_cast&lt;sc_core::sc_export&lt;tlm::tlm_fw_transport_if&lt;TYPES&gt; &gt;*&gt;(&amp;s);
<a name="l00178"></a>00178     if (!p_ex_s) display_error("Multi socket not bound to tlm_socket.");
<a name="l00179"></a>00179     
<a name="l00180"></a>00180     <span class="comment">//try a cast into a multi sockets</span>
<a name="l00181"></a>00181     multi_to_multi_bind_base&lt;TYPES&gt;* test=dynamic_cast&lt;multi_to_multi_bind_base&lt;TYPES&gt;*&gt; (p_ex_s);
<a name="l00182"></a>00182     if (test) <span class="comment">//did we just do a multi-multi bind??</span>
<a name="l00183"></a>00183       <span class="comment">//if that is the case the multi target socket must have just created a callback binder</span>
<a name="l00184"></a>00184       <span class="comment">// which we want to get from it.</span>
<a name="l00185"></a>00185       <span class="comment">//Moreover, we also just created one, which we will pass to it.</span>
<a name="l00186"></a>00186       m_sockets.push_back(test-&gt;get_last_binder(m_binders[m_binders.size()-1])); 
<a name="l00187"></a>00187     else{  <span class="comment">// if not just bind normally</span>
<a name="l00188"></a>00188       sc_core::sc_export&lt;tlm::tlm_fw_transport_if&lt;TYPES&gt; &gt;&amp; ex_s=*p_ex_s;
<a name="l00189"></a>00189       m_sockets.push_back(&amp;((tlm::tlm_fw_transport_if&lt;TYPES&gt;&amp;)ex_s)); <span class="comment">//store the interface we are bound against</span>
<a name="l00190"></a>00190     }
<a name="l00191"></a>00191   }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   <span class="comment">//operator notation for direct bind</span>
<a name="l00194"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#f732774c680a658512af6860f21037d1">00194</a>   void operator() (base_target_socket_type&amp; s)
<a name="l00195"></a>00195   {
<a name="l00196"></a>00196     bind(s);
<a name="l00197"></a>00197   }
<a name="l00198"></a>00198   
<a name="l00199"></a>00199   <span class="comment">//SystemC standard callback before end of elaboration</span>
<a name="l00200"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#6c55374f7d5e9b6c4b0f4c9ee4f7e456">00200</a>   void before_end_of_elaboration(){
<a name="l00201"></a>00201     <span class="comment">//if our export hasn't been bound yet (due to a hierarch binding)</span>
<a name="l00202"></a>00202     <span class="comment">// we bind it now to avoid a SystemC error.</span>
<a name="l00203"></a>00203     <span class="comment">//We must do that, because it is legal not to register a callback on this socket</span>
<a name="l00204"></a>00204     <span class="comment">// as the user might only use b_transport</span>
<a name="l00205"></a>00205     if (!base_type::m_export.get_interface()){ 
<a name="l00206"></a>00206       base_type::m_export.bind(m_dummy);      
<a name="l00207"></a>00207     }
<a name="l00208"></a>00208     
<a name="l00209"></a>00209     <span class="comment">//'break' here if the socket was told not to do callback binding</span>
<a name="l00210"></a>00210     if (m_beoe_disabled) return;
<a name="l00211"></a>00211     
<a name="l00212"></a>00212     <span class="comment">//get the callback binders of the top of the hierachical bind chain</span>
<a name="l00213"></a>00213     <span class="comment">// NOTE: this could be the same socket if there is no hierachical bind</span>
<a name="l00214"></a>00214     std::vector&lt;callback_binder_bw&lt;TYPES&gt;* &gt;&amp; binders=get_hierarch_bind()-&gt;get_binders();
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     <span class="comment">//get the interfaces bound to the top of the hierachical bind chain</span>
<a name="l00217"></a>00217     <span class="comment">// NOTE: this could be the same socket if there is no hierachical bind</span>
<a name="l00218"></a>00218     m_used_sockets=get_hierarch_bind()-&gt;get_sockets();
<a name="l00219"></a>00219     
<a name="l00220"></a>00220     <span class="comment">//register the callbacks of this socket with the callback binders</span>
<a name="l00221"></a>00221     <span class="comment">// we just got from the top of the hierachical bind chain</span>
<a name="l00222"></a>00222     for (unsigned int i=0; i&lt;binders.size(); i++) {
<a name="l00223"></a>00223       binders[i]-&gt;set_callbacks(m_nb_f, m_dmi_f);
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225   }
<a name="l00226"></a>00226 
<a name="l00227"></a>00227   <span class="comment">//</span>
<a name="l00228"></a>00228   <span class="comment">// Bind multi initiator socket to multi initiator socket (hierarchical bind)</span>
<a name="l00229"></a>00229   <span class="comment">//</span>
<a name="l00230"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#33b278874b8f5b93965f5d8fc55b58bb">00230</a>   void bind(base_type&amp; s)
<a name="l00231"></a>00231   {
<a name="l00232"></a>00232     if (m_binders.size()) <span class="comment">//a multi socket is either bound hierarchically or directly</span>
<a name="l00233"></a>00233       display_error("Socket already directly bound.");
<a name="l00234"></a>00234     if (m_hierarch_bind){
<a name="l00235"></a>00235       display_warning("Socket already bound hierarchically. Bind attempt ignored.");
<a name="l00236"></a>00236       return;
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238     
<a name="l00239"></a>00239     <span class="comment">//remember to which socket we are hierarchically bound and disable it, </span>
<a name="l00240"></a>00240     <span class="comment">// so that it won't try to register callbacks itself</span>
<a name="l00241"></a>00241     s.disable_cb_bind();
<a name="l00242"></a>00242     m_hierarch_bind=&amp;s;    
<a name="l00243"></a>00243     base_type::bind(s); <span class="comment">//satisfy SystemC</span>
<a name="l00244"></a>00244   }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246   <span class="comment">//operator notation for hierarchical bind</span>
<a name="l00247"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#14200c1b573e7e096913535b0f2e3e6f">00247</a>   void operator() (base_type&amp; s)
<a name="l00248"></a>00248   {
<a name="l00249"></a>00249     bind(s);
<a name="l00250"></a>00250   }
<a name="l00251"></a>00251 
<a name="l00252"></a>00252   <span class="comment">//get access to sub port</span>
<a name="l00253"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#41797e7abe235f3c5e6efd3c246b8d8a">00253</a>   tlm::tlm_fw_transport_if&lt;TYPES&gt;* operator[](int i){return m_used_sockets[i];}
<a name="l00254"></a>00254   
<a name="l00255"></a>00255   <span class="comment">//get the number of bound targets</span>
<a name="l00256"></a>00256   <span class="comment">// NOTE: this is only valid at end of elaboration!</span>
<a name="l00257"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#7c2d6187d9de379f06007c4085ce7d32">00257</a>   unsigned int size() {return get_hierarch_bind()-&gt;get_sockets().size();}
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 protected:
<a name="l00260"></a>00260   <span class="comment">//implementation of base class interface</span>
<a name="l00261"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#f160c9ebe2b88f8b3f266effea94d571">00261</a>   base_type* get_hierarch_bind(){if (m_hierarch_bind) return m_hierarch_bind-&gt;get_hierarch_bind(); else return this;}
<a name="l00262"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#a5dcdec260f84b5dfa514726f9b3b694">00262</a>   void disable_cb_bind(){ m_beoe_disabled=true;}
<a name="l00263"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#4bcf3102e9bc2a903675b413c6b249aa">00263</a>   std::vector&lt;callback_binder_bw&lt;TYPES&gt;* &gt;&amp; get_binders(){return m_binders;}
<a name="l00264"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#f2eab34a10975b7566e385d0ee7cb04e">00264</a>   std::vector&lt;tlm::tlm_fw_transport_if&lt;TYPES&gt;*&gt;&amp; get_sockets(){return m_sockets;}
<a name="l00265"></a>00265   <span class="comment">//vector of connected sockets</span>
<a name="l00266"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#51a25ff90a86be76a0039fd94063790b">00266</a>   std::vector&lt;tlm::tlm_fw_transport_if&lt;TYPES&gt;*&gt; m_sockets;
<a name="l00267"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#55b13a553f43a092ad6a97ca7d98c8a4">00267</a>   std::vector&lt;tlm::tlm_fw_transport_if&lt;TYPES&gt;*&gt; m_used_sockets;
<a name="l00268"></a>00268   <span class="comment">//vector of binders that convert untagged interface into tagged interface</span>
<a name="l00269"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#4abda8ae69c353b31ed06065ef7afcfd">00269</a>   std::vector&lt;callback_binder_bw&lt;TYPES&gt;*&gt; m_binders;
<a name="l00270"></a>00270   
<a name="l00271"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#c8f30a18afbb343f48a3b204555181fb">00271</a>   base_type*  m_hierarch_bind; <span class="comment">//pointer to hierarchical bound multi port</span>
<a name="l00272"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#ef91eeb042540b72d334be6ef94be5b2">00272</a>   bool m_beoe_disabled;  <span class="comment">// bool that remembers whether this socket shall bind callbacks or not</span>
<a name="l00273"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#d52c193b2ea265be7410b0ee9632d786">00273</a>   callback_binder_bw&lt;TYPES&gt; m_dummy; <span class="comment">//a callback binder that is bound to the underlying export</span>
<a name="l00274"></a>00274                                      <span class="comment">// in case there was no real bind</span>
<a name="l00275"></a>00275 
<a name="l00276"></a>00276   <span class="comment">//callbacks as functors</span>
<a name="l00277"></a>00277   <span class="comment">// (allows to pass the callback to another socket that does not know the type of the module that owns</span>
<a name="l00278"></a>00278   <span class="comment">//  the callbacks)</span>
<a name="l00279"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#3b6a674752ec8fcd72d4d1d3fd2280ad">00279</a>   typename callback_binder_bw&lt;TYPES&gt;::nb_func_type  m_nb_f;
<a name="l00280"></a><a class="code" href="classtlm__utils_1_1multi__passthrough__initiator__socket.html#806e9dbf3da5c3942be01215e476e1f4">00280</a>   typename callback_binder_bw&lt;TYPES&gt;::dmi_func_type m_dmi_f;
<a name="l00281"></a>00281 };
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 #endif
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Jul 15 13:46:49 2009 for TLM-2.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
