<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TLM-2.0: include/tlm/tlm_h/tlm_generic_payload/tlm_endian_conv.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>include/tlm/tlm_h/tlm_generic_payload/tlm_endian_conv.h</h1><a href="tlm__endian__conv_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*****************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  The following code is derived, directly or indirectly, from the SystemC</span>
<a name="l00004"></a>00004 <span class="comment">  source code Copyright (c) 1996-2008 by all Contributors.</span>
<a name="l00005"></a>00005 <span class="comment">  All Rights reserved.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">  The contents of this file are subject to the restrictions and limitations</span>
<a name="l00008"></a>00008 <span class="comment">  set forth in the SystemC Open Source License Version 3.0 (the "License");</span>
<a name="l00009"></a>00009 <span class="comment">  You may not use this file except in compliance with such restrictions and</span>
<a name="l00010"></a>00010 <span class="comment">  limitations. You may obtain instructions on how to receive a copy of the</span>
<a name="l00011"></a>00011 <span class="comment">  License at http://www.systemc.org/. Software distributed by Contributors</span>
<a name="l00012"></a>00012 <span class="comment">  under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF</span>
<a name="l00013"></a>00013 <span class="comment">  ANY KIND, either express or implied. See the License for the specific</span>
<a name="l00014"></a>00014 <span class="comment">  language governing rights and limitations under the License.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">*****************************************************************************/</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#ifndef __TLM_ENDIAN_CONV_H__</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#define __TLM_ENDIAN_CONV_H__</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;systemc&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include "<a class="code" href="tlm__gp_8h.html">tlm_gp.h</a>"</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="keyword">namespace </span>tlm {
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="comment">/*</span>
<a name="l00030"></a>00030 <span class="comment">Tranaction-Level Modelling</span>
<a name="l00031"></a>00031 <span class="comment">Endianness Helper Functions</span>
<a name="l00032"></a>00032 <span class="comment"></span>
<a name="l00033"></a>00033 <span class="comment">DESCRIPTION</span>
<a name="l00034"></a>00034 <span class="comment">A set of functions for helping users to get the endianness</span>
<a name="l00035"></a>00035 <span class="comment">right in their TLM models of system initiators.  These functions are</span>
<a name="l00036"></a>00036 <span class="comment">for use within an initiator.  They can not be used as-is outside</span>
<a name="l00037"></a>00037 <span class="comment">an initiator because the extension used to store context will not work</span>
<a name="l00038"></a>00038 <span class="comment">if cascaded, and they do not respect the generic payload mutability</span>
<a name="l00039"></a>00039 <span class="comment">rules.  However this code may be easily copied and adapted for use</span>
<a name="l00040"></a>00040 <span class="comment">in bridges, etc..</span>
<a name="l00041"></a>00041 <span class="comment"></span>
<a name="l00042"></a>00042 <span class="comment">These functions are not compulsory.  There are other legitimate ways to</span>
<a name="l00043"></a>00043 <span class="comment">achieve the same functionality.  If extra information is available at</span>
<a name="l00044"></a>00044 <span class="comment">compile time about the nature of an initiator's transactions, this can</span>
<a name="l00045"></a>00045 <span class="comment">be exploited to accelerate simulations by creating further functions</span>
<a name="l00046"></a>00046 <span class="comment">similar to those in this file.  In general a functional transaction can be</span>
<a name="l00047"></a>00047 <span class="comment">described in more than one way by a TLM-2 GP object.</span>
<a name="l00048"></a>00048 <span class="comment"></span>
<a name="l00049"></a>00049 <span class="comment">The functions convert the endianness of a GP object, either on request or</span>
<a name="l00050"></a>00050 <span class="comment">response.  They should only be used when the initiator's endianness</span>
<a name="l00051"></a>00051 <span class="comment">does not match the host's endianness.  They assume 'arithmetic mode'</span>
<a name="l00052"></a>00052 <span class="comment">meaning that within a data word the byte order is always host-endian.</span>
<a name="l00053"></a>00053 <span class="comment">For non-arithmetic mode initiators they can be used with a data word</span>
<a name="l00054"></a>00054 <span class="comment">size of 1 byte.</span>
<a name="l00055"></a>00055 <span class="comment"></span>
<a name="l00056"></a>00056 <span class="comment">All the functions are templates, for example:</span>
<a name="l00057"></a>00057 <span class="comment"></span>
<a name="l00058"></a>00058 <span class="comment">template&lt;class DATAWORD&gt; inline void</span>
<a name="l00059"></a>00059 <span class="comment">  to_hostendian_generic(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00060"></a>00060 <span class="comment"></span>
<a name="l00061"></a>00061 <span class="comment">The template parameter provides the data word width.  Having this as a class</span>
<a name="l00062"></a>00062 <span class="comment">makes it easy to use it for copy and swap operations within the functions.</span>
<a name="l00063"></a>00063 <span class="comment">If the assignment operator for this class is overloaded, the endianness</span>
<a name="l00064"></a>00064 <span class="comment">conversion function may not have the desired effect.</span>
<a name="l00065"></a>00065 <span class="comment"></span>
<a name="l00066"></a>00066 <span class="comment">All the functions have the same signature except for different names.</span>
<a name="l00067"></a>00067 <span class="comment"></span>
<a name="l00068"></a>00068 <span class="comment">The principle is that a function to_hostendian_convtype() is called when the</span>
<a name="l00069"></a>00069 <span class="comment">initiator-endian transaction is created, and the matching function</span>
<a name="l00070"></a>00070 <span class="comment">from_hostendian_convtype() is called when the transaction is completed, for</span>
<a name="l00071"></a>00071 <span class="comment">example before read data can be used.  In some cases the from_ function is</span>
<a name="l00072"></a>00072 <span class="comment">redundant but an empty function is provided anyway.  It is strongly</span>
<a name="l00073"></a>00073 <span class="comment">recommended that the from_ function is called, in case it ceases to be</span>
<a name="l00074"></a>00074 <span class="comment">redundant in future versions of this code.</span>
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">No context needs to be managed outside the two functions, except that they</span>
<a name="l00077"></a>00077 <span class="comment">must be called with the same template parameter and the same bus width.</span>
<a name="l00078"></a>00078 <span class="comment"></span>
<a name="l00079"></a>00079 <span class="comment">For initiator models that can not easily manage this context information,</span>
<a name="l00080"></a>00080 <span class="comment">a single entry point for the from_ function is provided, which will be</span>
<a name="l00081"></a>00081 <span class="comment">a little slower than calling the correct from_ function directly, as</span>
<a name="l00082"></a>00082 <span class="comment">it can not be inlined.</span>
<a name="l00083"></a>00083 <span class="comment"></span>
<a name="l00084"></a>00084 <span class="comment">All functions assume power-of-2 bus and data word widths.</span>
<a name="l00085"></a>00085 <span class="comment"></span>
<a name="l00086"></a>00086 <span class="comment">Functions offered:</span>
<a name="l00087"></a>00087 <span class="comment"></span>
<a name="l00088"></a>00088 <span class="comment">0) A pair of functions that work for almost all TLM2 GP transactions.  The</span>
<a name="l00089"></a>00089 <span class="comment">only limitations are that data and bus widths should be powers of 2, and that</span>
<a name="l00090"></a>00090 <span class="comment">the data length should be an integer number of streaming widths and that the</span>
<a name="l00091"></a>00091 <span class="comment">streaming width should be an integer number of data words.</span>
<a name="l00092"></a>00092 <span class="comment">These functions always allocate new data and byte enable buffers and copy</span>
<a name="l00093"></a>00093 <span class="comment">data one byte at a time.</span>
<a name="l00094"></a>00094 <span class="comment">  tlm_to_hostendian_generic(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00095"></a>00095 <span class="comment">  tlm_from_hostendian_generic(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00096"></a>00096 <span class="comment"></span>
<a name="l00097"></a>00097 <span class="comment">1) A pair of functions that work for all transactions regardless of data and</span>
<a name="l00098"></a>00098 <span class="comment">bus data sizes and address alignment except for the the following</span>
<a name="l00099"></a>00099 <span class="comment">limitations:</span>
<a name="l00100"></a>00100 <span class="comment">- byte-enables are supported only when byte-enable granularity is no finer</span>
<a name="l00101"></a>00101 <span class="comment">than the data word (every data word is wholly enabled or wholly disabled)</span>
<a name="l00102"></a>00102 <span class="comment">- byte-enable-length is not supported (if byte enables are present, the byte</span>
<a name="l00103"></a>00103 <span class="comment">enable length must be equal to the data length).</span>
<a name="l00104"></a>00104 <span class="comment">- streaming width is not supported</span>
<a name="l00105"></a>00105 <span class="comment">- data word wider than bus word is not supported</span>
<a name="l00106"></a>00106 <span class="comment">A new data buffer and a new byte enable buffer are always allocated.  Byte</span>
<a name="l00107"></a>00107 <span class="comment">enables are assumed to be needed even if not required for the original</span>
<a name="l00108"></a>00108 <span class="comment">(unconverted) transaction.  Data is copied to the new buffer on request</span>
<a name="l00109"></a>00109 <span class="comment">(for writes) or on response (for reads).  Copies are done word-by-word</span>
<a name="l00110"></a>00110 <span class="comment">where possible.</span>
<a name="l00111"></a>00111 <span class="comment">  tlm_to_hostendian_word(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00112"></a>00112 <span class="comment">  tlm_from_hostendian_word(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00113"></a>00113 <span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment">2) If the original transaction is both word and bus-aligned then this pair of</span>
<a name="l00115"></a>00115 <span class="comment">functions can be used.  It will complete faster than the generic function</span>
<a name="l00116"></a>00116 <span class="comment">because the data reordering function is much simpler and no address</span>
<a name="l00117"></a>00117 <span class="comment">conversion is required.</span>
<a name="l00118"></a>00118 <span class="comment">The following limitations apply:</span>
<a name="l00119"></a>00119 <span class="comment">- byte-enables are supported only when byte-enable granularity is no finer</span>
<a name="l00120"></a>00120 <span class="comment">than the data word (every data word is wholly enabled or wholly disabled)</span>
<a name="l00121"></a>00121 <span class="comment">- byte-enable-length is not supported (if byte enables are present, the byte</span>
<a name="l00122"></a>00122 <span class="comment">enable length must be equal to the data length).</span>
<a name="l00123"></a>00123 <span class="comment">- streaming width is not supported</span>
<a name="l00124"></a>00124 <span class="comment">- data word wider than bus word is not supported</span>
<a name="l00125"></a>00125 <span class="comment">- the transaction must be an integer number of bus words</span>
<a name="l00126"></a>00126 <span class="comment">- the address must be aligned to the bus width</span>
<a name="l00127"></a>00127 <span class="comment">  tlm_to_hostendian_aligned(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00128"></a>00128 <span class="comment">  tlm_from_hostendian_aligned(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00129"></a>00129 <span class="comment"></span>
<a name="l00130"></a>00130 <span class="comment">3) For single word transactions that don't cross a bus word boundary it</span>
<a name="l00131"></a>00131 <span class="comment">is always safe to work in-place and the conversion is very simple.  Again,</span>
<a name="l00132"></a>00132 <span class="comment">streaming width and byte-enable length are not supported, and byte-enables</span>
<a name="l00133"></a>00133 <span class="comment">may not changes within a data word.</span>
<a name="l00134"></a>00134 <span class="comment">  tlm_to_hostendian_single(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00135"></a>00135 <span class="comment">  tlm_from_hostendian_single(tlm_generic_payload *txn, int sizeof_databus)</span>
<a name="l00136"></a>00136 <span class="comment"></span>
<a name="l00137"></a>00137 <span class="comment">4) A single entry point for accessing the correct from_ function without</span>
<a name="l00138"></a>00138 <span class="comment">needing to store context.</span>
<a name="l00139"></a>00139 <span class="comment">  tlm_from_hostendian(tlm_generic_payload *txn)</span>
<a name="l00140"></a>00140 <span class="comment">*/</span>
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="preprocessor">#ifndef uchar</span>
<a name="l00145"></a><a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">00145</a> <span class="preprocessor"></span><span class="preprocessor">#define uchar unsigned char</span>
<a name="l00146"></a>00146 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00147"></a>00147 <span class="preprocessor"></span><span class="preprocessor">#define TLM_END_CONV_DONT_UNDEF_UCHAR</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00149"></a>00149 <span class="preprocessor"></span>
<a name="l00150"></a>00150 
<a name="l00152"></a>00152 <span class="comment">// Generic Utilities</span>
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keyword">class </span>tlm_endian_context;
<a name="l00155"></a><a class="code" href="classtlm_1_1tlm__endian__context__pool.html">00155</a> <span class="keyword">class </span><a class="code" href="classtlm_1_1tlm__endian__context__pool.html">tlm_endian_context_pool</a> {
<a name="l00156"></a>00156   <span class="keyword">public</span>:
<a name="l00157"></a><a class="code" href="classtlm_1_1tlm__endian__context__pool.html#73dea6477d0aa6498f04c664432c5a76">00157</a>     <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *<a class="code" href="classtlm_1_1tlm__endian__context__pool.html#73dea6477d0aa6498f04c664432c5a76">first</a>;
<a name="l00158"></a>00158     <span class="keyword">inline</span> <a class="code" href="classtlm_1_1tlm__endian__context__pool.html#55547e739563478725d4a5a089147050">tlm_endian_context_pool</a>();
<a name="l00159"></a>00159     <span class="keyword">inline</span> <a class="code" href="classtlm_1_1tlm__endian__context__pool.html#fb3b7b00dfcbb56ff7c16e4b8423cec7">~tlm_endian_context_pool</a>();
<a name="l00160"></a>00160     <span class="keyword">inline</span> <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *<a class="code" href="classtlm_1_1tlm__endian__context__pool.html#a38c31e12f7ccc9a2610442de40074a8">pop</a>();
<a name="l00161"></a>00161     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classtlm_1_1tlm__endian__context__pool.html#9fdbced80c0806f06b828ee8d8abbe4d">push</a>(<a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *c);
<a name="l00162"></a>00162 };
<a name="l00163"></a>00163 <span class="keyword">static</span> <a class="code" href="classtlm_1_1tlm__endian__context__pool.html">tlm_endian_context_pool</a> global_tlm_endian_context_pool;
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="comment">// an extension to keep the information needed for reconversion of response</span>
<a name="l00166"></a><a class="code" href="classtlm_1_1tlm__endian__context.html">00166</a> <span class="keyword">class </span><a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> : <span class="keyword">public</span> <a class="code" href="classtlm_1_1tlm__extension.html">tlm_extension</a>&lt;tlm_endian_context&gt; {
<a name="l00167"></a>00167   <span class="keyword">public</span>:
<a name="l00168"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#4e4d0854fd319afef702cfc3d92d4225">00168</a>     <a class="code" href="classtlm_1_1tlm__endian__context.html#4e4d0854fd319afef702cfc3d92d4225">tlm_endian_context</a>() : <a class="code" href="classtlm_1_1tlm__endian__context.html#8e7bccafad1987ed0053e00f9ec422fb">dbuf_size</a>(0), <a class="code" href="classtlm_1_1tlm__endian__context.html#c78a65ded76e412bac9973765c6d7ae5">bebuf_size</a>(0) {}
<a name="l00169"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#6647f750726e6c2ac5edabe569dde4bd">00169</a>     <a class="code" href="classtlm_1_1tlm__endian__context.html#6647f750726e6c2ac5edabe569dde4bd">~tlm_endian_context</a>() {
<a name="l00170"></a>00170       <span class="keywordflow">if</span>(<a class="code" href="classtlm_1_1tlm__endian__context.html#8e7bccafad1987ed0053e00f9ec422fb">dbuf_size</a> &gt; 0) <span class="keyword">delete</span> [] <a class="code" href="classtlm_1_1tlm__endian__context.html#881e78625efff381112316271f8c0baa">new_dbuf</a>;
<a name="l00171"></a>00171       <span class="keywordflow">if</span>(<a class="code" href="classtlm_1_1tlm__endian__context.html#c78a65ded76e412bac9973765c6d7ae5">bebuf_size</a> &gt; 0) <span class="keyword">delete</span> [] <a class="code" href="classtlm_1_1tlm__endian__context.html#32ee9f4cae59221799c53558e01aff04">new_bebuf</a>;
<a name="l00172"></a>00172     }
<a name="l00173"></a>00173 
<a name="l00174"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">00174</a>     sc_dt::uint64 <a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a>;     <span class="comment">// used by generic, word</span>
<a name="l00175"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#4b592ed6192127e7f2df6c810bbf1499">00175</a>     sc_dt::uint64 <a class="code" href="classtlm_1_1tlm__endian__context.html#4b592ed6192127e7f2df6c810bbf1499">new_address</a>;     <span class="comment">// used by generic</span>
<a name="l00176"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">00176</a>     <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>;     <span class="comment">// used by generic, word, aligned</span>
<a name="l00177"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#e4a357d465b80c6c6b049e48a736d34b">00177</a>     <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *<a class="code" href="classtlm_1_1tlm__endian__context.html#e4a357d465b80c6c6b049e48a736d34b">byte_enable</a>;  <span class="comment">// used by word</span>
<a name="l00178"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#caa2d690d4f526cbf6b39575033d717e">00178</a>     <span class="keywordtype">int</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#caa2d690d4f526cbf6b39575033d717e">length</a>;         <span class="comment">// used by generic, word</span>
<a name="l00179"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#d43407778698362ee2f0b92b9b43394a">00179</a>     <span class="keywordtype">int</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#d43407778698362ee2f0b92b9b43394a">stream_width</a>;   <span class="comment">// used by generic</span>
<a name="l00180"></a>00180 
<a name="l00181"></a>00181     <span class="comment">// used by common entry point on response</span>
<a name="l00182"></a>00182     void (*<a class="code" href="classtlm_1_1tlm__endian__context.html#d6c5b6fb7e74f050d115825408688dab">from_f</a>)(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">sizeof_databus</a>);
<a name="l00183"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">00183</a>     <span class="keywordtype">int</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">sizeof_databus</a>;
<a name="l00184"></a>00184 
<a name="l00185"></a>00185     <span class="comment">// reordering buffers for data and byte-enables</span>
<a name="l00186"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#881e78625efff381112316271f8c0baa">00186</a>     <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *<a class="code" href="classtlm_1_1tlm__endian__context.html#881e78625efff381112316271f8c0baa">new_dbuf</a>, *<a class="code" href="classtlm_1_1tlm__endian__context.html#32ee9f4cae59221799c53558e01aff04">new_bebuf</a>;
<a name="l00187"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#8e7bccafad1987ed0053e00f9ec422fb">00187</a>     <span class="keywordtype">int</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#8e7bccafad1987ed0053e00f9ec422fb">dbuf_size</a>, <a class="code" href="classtlm_1_1tlm__endian__context.html#c78a65ded76e412bac9973765c6d7ae5">bebuf_size</a>;
<a name="l00188"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#e667b8c79527e2ac2fe5355e1e5854d5">00188</a>     <span class="keywordtype">void</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#e667b8c79527e2ac2fe5355e1e5854d5">establish_dbuf</a>(<span class="keywordtype">int</span> len) {
<a name="l00189"></a>00189       <span class="keywordflow">if</span>(len &lt;= <a class="code" href="classtlm_1_1tlm__endian__context.html#8e7bccafad1987ed0053e00f9ec422fb">dbuf_size</a>) <span class="keywordflow">return</span>;
<a name="l00190"></a>00190       <span class="keywordflow">if</span>(<a class="code" href="classtlm_1_1tlm__endian__context.html#8e7bccafad1987ed0053e00f9ec422fb">dbuf_size</a> &gt; 0) <span class="keyword">delete</span> [] <a class="code" href="classtlm_1_1tlm__endian__context.html#881e78625efff381112316271f8c0baa">new_dbuf</a>;
<a name="l00191"></a>00191       <a class="code" href="classtlm_1_1tlm__endian__context.html#881e78625efff381112316271f8c0baa">new_dbuf</a> = <span class="keyword">new</span> <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>[len];
<a name="l00192"></a>00192       <a class="code" href="classtlm_1_1tlm__endian__context.html#8e7bccafad1987ed0053e00f9ec422fb">dbuf_size</a> = len;
<a name="l00193"></a>00193     }
<a name="l00194"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#e291fca8f514174828d9d17b3adbe4ba">00194</a>     <span class="keywordtype">void</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#e291fca8f514174828d9d17b3adbe4ba">establish_bebuf</a>(<span class="keywordtype">int</span> len) {
<a name="l00195"></a>00195       <span class="keywordflow">if</span>(len &lt;= <a class="code" href="classtlm_1_1tlm__endian__context.html#c78a65ded76e412bac9973765c6d7ae5">bebuf_size</a>) <span class="keywordflow">return</span>;
<a name="l00196"></a>00196       <span class="keywordflow">if</span>(<a class="code" href="classtlm_1_1tlm__endian__context.html#c78a65ded76e412bac9973765c6d7ae5">bebuf_size</a> &gt; 0) <span class="keyword">delete</span> [] <a class="code" href="classtlm_1_1tlm__endian__context.html#32ee9f4cae59221799c53558e01aff04">new_bebuf</a>;
<a name="l00197"></a>00197       <a class="code" href="classtlm_1_1tlm__endian__context.html#32ee9f4cae59221799c53558e01aff04">new_bebuf</a> = <span class="keyword">new</span> <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>[len];
<a name="l00198"></a>00198       <a class="code" href="classtlm_1_1tlm__endian__context.html#c78a65ded76e412bac9973765c6d7ae5">bebuf_size</a> = len;
<a name="l00199"></a>00199     }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201     <span class="comment">// required for extension management</span>
<a name="l00202"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#260582657c6ebcd9f650d5df38242c7b">00202</a>     <span class="keywordtype">void</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#260582657c6ebcd9f650d5df38242c7b">free</a>() {
<a name="l00203"></a>00203       global_tlm_endian_context_pool.<a class="code" href="classtlm_1_1tlm__endian__context__pool.html#9fdbced80c0806f06b828ee8d8abbe4d">push</a>(<span class="keyword">this</span>);
<a name="l00204"></a>00204     }
<a name="l00205"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#9cbad660fb75aef9f1f8cacc7104175c">00205</a>     <a class="code" href="classtlm_1_1tlm__extension__base.html">tlm_extension_base</a>* <a class="code" href="classtlm_1_1tlm__endian__context.html#9cbad660fb75aef9f1f8cacc7104175c">clone</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> 0;}
<a name="l00206"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#3ae93523f40ea5aa42e29992a4ef2ac0">00206</a>     <span class="keywordtype">void</span> <a class="code" href="classtlm_1_1tlm__endian__context.html#3ae93523f40ea5aa42e29992a4ef2ac0">copy_from</a>(<a class="code" href="classtlm_1_1tlm__extension__base.html">tlm_extension_base</a> <span class="keyword">const</span> &amp;) {<span class="keywordflow">return</span>;}
<a name="l00207"></a>00207 
<a name="l00208"></a>00208     <span class="comment">// for pooling</span>
<a name="l00209"></a><a class="code" href="classtlm_1_1tlm__endian__context.html#4c0fdcaea2fff64e1eeb8b3650bc8686">00209</a>     <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *<a class="code" href="classtlm_1_1tlm__endian__context.html#4c0fdcaea2fff64e1eeb8b3650bc8686">next</a>;
<a name="l00210"></a>00210 };
<a name="l00211"></a>00211 <span class="comment">// Assumptions about transaction contexts:</span>
<a name="l00212"></a>00212 <span class="comment">// 1) only the address attribute of a transaction</span>
<a name="l00213"></a>00213 <span class="comment">// is mutable.  all other attributes are unchanged from the request to</span>
<a name="l00214"></a>00214 <span class="comment">// response side conversion.</span>
<a name="l00215"></a>00215 <span class="comment">// 2) the conversion functions in this file do not respect the mutability</span>
<a name="l00216"></a>00216 <span class="comment">// rules and do not put the transaction back into its original state after</span>
<a name="l00217"></a>00217 <span class="comment">// completion.  so if the initiator has any cleaning up to do (eg of byte</span>
<a name="l00218"></a>00218 <span class="comment">// enable buffers), it needs to store its own context.  the transaction</span>
<a name="l00219"></a>00219 <span class="comment">// returned to the initiator may contain pointers to data and byte enable</span>
<a name="l00220"></a>00220 <span class="comment">// that can/must not be deleted.</span>
<a name="l00221"></a>00221 <span class="comment">// 3) the conversion functions in this file use an extension to store</span>
<a name="l00222"></a>00222 <span class="comment">// context information.  they do not remove this extension.  the initiator</span>
<a name="l00223"></a>00223 <span class="comment">// should not remove it unless it deletes the generic payload</span>
<a name="l00224"></a>00224 <span class="comment">// object.</span>
<a name="l00225"></a>00225 
<a name="l00226"></a><a class="code" href="namespacetlm.html#3d28c3714f7375334465f92755ed3e36">00226</a> <span class="keyword">inline</span> <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *<a class="code" href="namespacetlm.html#3d28c3714f7375334465f92755ed3e36">establish_context</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn) {
<a name="l00227"></a>00227   <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#57e1f088841057cd1c2717701c240396">get_extension</a>&lt;<a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a>&gt;();
<a name="l00228"></a>00228   <span class="keywordflow">if</span>(tc == 0) {
<a name="l00229"></a>00229     tc = global_tlm_endian_context_pool.<a class="code" href="classtlm_1_1tlm__endian__context__pool.html#a38c31e12f7ccc9a2610442de40074a8">pop</a>();
<a name="l00230"></a>00230     txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#736d6fe355b64be5280ba32386566163">set_extension</a>(tc);
<a name="l00231"></a>00231   }
<a name="l00232"></a>00232   <span class="keywordflow">return</span> tc;
<a name="l00233"></a>00233 }
<a name="l00234"></a>00234 
<a name="l00235"></a><a class="code" href="classtlm_1_1tlm__endian__context__pool.html#55547e739563478725d4a5a089147050">00235</a> <span class="keyword">inline</span> <a class="code" href="classtlm_1_1tlm__endian__context__pool.html#55547e739563478725d4a5a089147050">tlm_endian_context_pool::tlm_endian_context_pool</a>() : first(0) {}
<a name="l00236"></a>00236 
<a name="l00237"></a><a class="code" href="classtlm_1_1tlm__endian__context__pool.html#fb3b7b00dfcbb56ff7c16e4b8423cec7">00237</a> <span class="keyword">inline</span> <a class="code" href="classtlm_1_1tlm__endian__context__pool.html#fb3b7b00dfcbb56ff7c16e4b8423cec7">tlm_endian_context_pool::~tlm_endian_context_pool</a>() {
<a name="l00238"></a>00238   <span class="keywordflow">while</span>(<a class="code" href="classtlm_1_1tlm__endian__context__pool.html#73dea6477d0aa6498f04c664432c5a76">first</a> != 0) {
<a name="l00239"></a>00239     <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *next = <a class="code" href="classtlm_1_1tlm__endian__context__pool.html#73dea6477d0aa6498f04c664432c5a76">first</a>-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#4c0fdcaea2fff64e1eeb8b3650bc8686">next</a>;
<a name="l00240"></a>00240     <span class="keyword">delete</span> <a class="code" href="classtlm_1_1tlm__endian__context__pool.html#73dea6477d0aa6498f04c664432c5a76">first</a>;
<a name="l00241"></a>00241     <a class="code" href="classtlm_1_1tlm__endian__context__pool.html#73dea6477d0aa6498f04c664432c5a76">first</a> = next;
<a name="l00242"></a>00242   }
<a name="l00243"></a>00243 }
<a name="l00244"></a>00244 
<a name="l00245"></a><a class="code" href="classtlm_1_1tlm__endian__context__pool.html#a38c31e12f7ccc9a2610442de40074a8">00245</a> <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *<a class="code" href="classtlm_1_1tlm__endian__context__pool.html#a38c31e12f7ccc9a2610442de40074a8">tlm_endian_context_pool::pop</a>() {
<a name="l00246"></a>00246   <span class="keywordflow">if</span>(<a class="code" href="classtlm_1_1tlm__endian__context__pool.html#73dea6477d0aa6498f04c664432c5a76">first</a> == 0) <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a>;
<a name="l00247"></a>00247   <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *r = <a class="code" href="classtlm_1_1tlm__endian__context__pool.html#73dea6477d0aa6498f04c664432c5a76">first</a>;
<a name="l00248"></a>00248   <a class="code" href="classtlm_1_1tlm__endian__context__pool.html#73dea6477d0aa6498f04c664432c5a76">first</a> = <a class="code" href="classtlm_1_1tlm__endian__context__pool.html#73dea6477d0aa6498f04c664432c5a76">first</a>-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#4c0fdcaea2fff64e1eeb8b3650bc8686">next</a>;
<a name="l00249"></a>00249   <span class="keywordflow">return</span> r;
<a name="l00250"></a>00250 }
<a name="l00251"></a>00251 
<a name="l00252"></a><a class="code" href="classtlm_1_1tlm__endian__context__pool.html#9fdbced80c0806f06b828ee8d8abbe4d">00252</a> <span class="keywordtype">void</span> <a class="code" href="classtlm_1_1tlm__endian__context__pool.html#9fdbced80c0806f06b828ee8d8abbe4d">tlm_endian_context_pool::push</a>(<a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *c) {
<a name="l00253"></a>00253   c-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#4c0fdcaea2fff64e1eeb8b3650bc8686">next</a> = <a class="code" href="classtlm_1_1tlm__endian__context__pool.html#73dea6477d0aa6498f04c664432c5a76">first</a>;
<a name="l00254"></a>00254   <a class="code" href="classtlm_1_1tlm__endian__context__pool.html#73dea6477d0aa6498f04c664432c5a76">first</a> = c;
<a name="l00255"></a>00255 }
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 <span class="comment">// a set of constants for efficient filling of byte enables</span>
<a name="l00259"></a><a class="code" href="classtlm_1_1tlm__bool.html">00259</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt; <span class="keyword">class </span><a class="code" href="classtlm_1_1tlm__bool.html">tlm_bool</a> {
<a name="l00260"></a>00260   <span class="keyword">public</span>:
<a name="l00261"></a><a class="code" href="classtlm_1_1tlm__bool.html#4d94e18943c3348ffc1a63d42dc7c05f">00261</a>     <span class="keyword">static</span> D <a class="code" href="classtlm_1_1tlm__bool.html#4d94e18943c3348ffc1a63d42dc7c05f">TLM_TRUE</a>;
<a name="l00262"></a><a class="code" href="classtlm_1_1tlm__bool.html#05e9260a8b590567d128501634a3c1f9">00262</a>     <span class="keyword">static</span> D <a class="code" href="classtlm_1_1tlm__bool.html#05e9260a8b590567d128501634a3c1f9">TLM_FALSE</a>;
<a name="l00263"></a><a class="code" href="classtlm_1_1tlm__bool.html#09a7ec73e84adb2c54878081e61e3799">00263</a>     <span class="keyword">static</span> D <a class="code" href="classtlm_1_1tlm__bool.html#09a7ec73e84adb2c54878081e61e3799">make_uchar_array</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> c) {
<a name="l00264"></a>00264       D d;
<a name="l00265"></a>00265       <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *tmp = (<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)(&amp;d);
<a name="l00266"></a>00266       <span class="keywordflow">for</span>(ptrdiff_t i=0; i!=<span class="keyword">sizeof</span>(D); i++) tmp[i] = c;  <span class="comment">// 64BITFIX negligable risk but easy fix //</span>
<a name="l00267"></a>00267       <span class="keywordflow">return</span> d;
<a name="l00268"></a>00268     }
<a name="l00269"></a>00269     <span class="comment">// also provides an syntax-efficient tester, using a</span>
<a name="l00270"></a>00270     <span class="comment">// copy constuctor and an implicit cast to boolean</span>
<a name="l00271"></a><a class="code" href="classtlm_1_1tlm__bool.html#9824e7f98684f1894b3db42108be58ef">00271</a>     <a class="code" href="classtlm_1_1tlm__bool.html#9824e7f98684f1894b3db42108be58ef">tlm_bool</a>(D &amp;d) : b(*((<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a>*)&amp;d) != <a class="code" href="tlm__gp_8h.html#ee6c671fa7a49f01da4a966f33067175">TLM_BYTE_DISABLED</a>) {}
<a name="l00272"></a><a class="code" href="classtlm_1_1tlm__bool.html#c2c0edb8930df836dd5dc6803b571629">00272</a>     <a class="code" href="classtlm_1_1tlm__bool.html#c2c0edb8930df836dd5dc6803b571629">operator bool</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> b;}
<a name="l00273"></a>00273   <span class="keyword">private</span>:
<a name="l00274"></a>00274     <span class="keywordtype">bool</span> b;
<a name="l00275"></a>00275 };
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt; D tlm_bool&lt;D&gt;::TLM_TRUE
<a name="l00278"></a>00278   = <a class="code" href="classtlm_1_1tlm__bool.html#09a7ec73e84adb2c54878081e61e3799">tlm_bool&lt;D&gt;::make_uchar_array</a>(<a class="code" href="tlm__gp_8h.html#f8d2c3eb34ebd54e62bb2016614a827f">TLM_BYTE_ENABLED</a>);
<a name="l00279"></a>00279 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt; D tlm_bool&lt;D&gt;::TLM_FALSE
<a name="l00280"></a>00280   = <a class="code" href="classtlm_1_1tlm__bool.html#09a7ec73e84adb2c54878081e61e3799">tlm_bool&lt;D&gt;::make_uchar_array</a>(<a class="code" href="tlm__gp_8h.html#ee6c671fa7a49f01da4a966f33067175">TLM_BYTE_DISABLED</a>);
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 
<a name="l00285"></a>00285 <span class="comment">// function set (0): Utilities</span>
<a name="l00286"></a><a class="code" href="namespacetlm.html#00c757c3a05f6f752c3517548d3d9bfc">00286</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#00c757c3a05f6f752c3517548d3d9bfc">copy_db0</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00287"></a>00287   *dest1 = *src1;
<a name="l00288"></a>00288   *dest2 = *src2;
<a name="l00289"></a>00289 }
<a name="l00290"></a>00290 
<a name="l00291"></a><a class="code" href="namespacetlm.html#fb865af12e7e2ef0312c50d4cb6d292a">00291</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#fb865af12e7e2ef0312c50d4cb6d292a">copy_dbtrue0</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00292"></a>00292   *dest1 = *src1;
<a name="l00293"></a>00293   *dest2 = <a class="code" href="tlm__gp_8h.html#f8d2c3eb34ebd54e62bb2016614a827f">TLM_BYTE_ENABLED</a>;
<a name="l00294"></a>00294 }
<a name="l00295"></a>00295 
<a name="l00296"></a><a class="code" href="namespacetlm.html#9b19018aacff8562c49b3b6b148847af">00296</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#9b19018aacff8562c49b3b6b148847af">copy_btrue0</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00297"></a>00297   *dest2 = <a class="code" href="tlm__gp_8h.html#f8d2c3eb34ebd54e62bb2016614a827f">TLM_BYTE_ENABLED</a>;
<a name="l00298"></a>00298 }
<a name="l00299"></a>00299 
<a name="l00300"></a><a class="code" href="namespacetlm.html#0c70f2866a851446adb12550d9c44fa5">00300</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#0c70f2866a851446adb12550d9c44fa5">copy_b0</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00301"></a>00301   *dest2 = *src2;
<a name="l00302"></a>00302 }
<a name="l00303"></a>00303 
<a name="l00304"></a><a class="code" href="namespacetlm.html#9daf63e27286c5e92fe8a614173323a9">00304</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#9daf63e27286c5e92fe8a614173323a9">copy_dbyb0</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00305"></a>00305   <span class="keywordflow">if</span>(*dest2 == <a class="code" href="tlm__gp_8h.html#f8d2c3eb34ebd54e62bb2016614a827f">TLM_BYTE_ENABLED</a>) *src1 = *dest1;
<a name="l00306"></a>00306 }
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 
<a name="l00309"></a>00309 <span class="keyword">template</span>&lt;<span class="keyword">class </span>D,
<a name="l00310"></a>00310   <span class="keywordtype">void</span> COPY(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *he_d, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *he_b, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *ie_d, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *ie_b)&gt;
<a name="l00311"></a><a class="code" href="namespacetlm.html#05d4d192746ca202086606dec7bacb82">00311</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#05d4d192746ca202086606dec7bacb82">loop_generic0</a>(<span class="keywordtype">int</span> new_len, <span class="keywordtype">int</span> new_stream_width,
<a name="l00312"></a>00312   <span class="keywordtype">int</span> orig_stream_width, <span class="keywordtype">int</span> sizeof_databus,
<a name="l00313"></a>00313   sc_dt::uint64 orig_start_address, sc_dt::uint64 new_start_address, <span class="keywordtype">int</span> be_length,
<a name="l00314"></a>00314   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *ie_data, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *ie_be, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *he_data, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *he_be) {
<a name="l00315"></a>00315 
<a name="l00316"></a>00316   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> orig_sword = 0, new_sword = 0; new_sword &lt; new_len;
<a name="l00317"></a>00317       new_sword += new_stream_width, orig_sword += orig_stream_width) {
<a name="l00318"></a>00318 
<a name="l00319"></a>00319     sc_dt::uint64 ie_addr = orig_start_address;
<a name="l00320"></a>00320     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> orig_dword = orig_sword;
<a name="l00321"></a>00321       orig_dword &lt; orig_sword + orig_stream_width; orig_dword += <span class="keyword">sizeof</span>(D)) {
<a name="l00322"></a>00322 
<a name="l00323"></a>00323       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> curr_byte = orig_dword + <span class="keyword">sizeof</span>(D) - 1;
<a name="l00324"></a>00324           curr_byte &gt;= orig_dword; curr_byte--) {
<a name="l00325"></a>00325 
<a name="l00326"></a>00326         ptrdiff_t he_index = ((ie_addr++) ^ (sizeof_databus - 1))
<a name="l00327"></a>00327           - new_start_address + new_sword;  <span class="comment">// 64BITFIX //</span>
<a name="l00328"></a>00328         COPY(ie_data+curr_byte,
<a name="l00329"></a>00329              ie_be+(curr_byte % be_length),  <span class="comment">// 64BITRISK no risk of overflow, always positive //</span>
<a name="l00330"></a>00330              he_data+he_index, he_be+he_index);
<a name="l00331"></a>00331       }
<a name="l00332"></a>00332     }
<a name="l00333"></a>00333   }
<a name="l00334"></a>00334 }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336 
<a name="l00338"></a>00338 <span class="comment">// function set (0): Response</span>
<a name="l00339"></a>00339 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00340"></a><a class="code" href="namespacetlm.html#5be70eaa5ff8579d2e411208f58a6e48">00340</a> <a class="code" href="namespacetlm.html#5be70eaa5ff8579d2e411208f58a6e48">tlm_from_hostendian_generic</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00341"></a>00341   <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#a99b26718e52fd5a49ab8475b44b8dac">is_read</a>()) {
<a name="l00342"></a>00342     <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = txn-&gt;template get_extension&lt;tlm_endian_context&gt;();
<a name="l00343"></a>00343     loop_generic0&lt;DATAWORD, &amp;copy_dbyb0&gt;(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>(),
<a name="l00344"></a>00344       txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#8cc2025a351f5fa8cf3e91a03a089a81">get_streaming_width</a>(), tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#d43407778698362ee2f0b92b9b43394a">stream_width</a>, sizeof_databus, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a>,
<a name="l00345"></a>00345       tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#4b592ed6192127e7f2df6c810bbf1499">new_address</a>, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>(), tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>, 0, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>(),
<a name="l00346"></a>00346       txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00347"></a>00347   }
<a name="l00348"></a>00348 }
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 
<a name="l00352"></a>00352 <span class="comment">// function set (0): Request</span>
<a name="l00353"></a>00353 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00354"></a><a class="code" href="namespacetlm.html#ac25bb86d1f480fd3155655502929131">00354</a> <a class="code" href="namespacetlm.html#ac25bb86d1f480fd3155655502929131">tlm_to_hostendian_generic</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00355"></a>00355   <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = <a class="code" href="namespacetlm.html#3d28c3714f7375334465f92755ed3e36">establish_context</a>(txn);
<a name="l00356"></a>00356   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#d6c5b6fb7e74f050d115825408688dab">from_f</a> = &amp;(tlm_from_hostendian_generic&lt;DATAWORD&gt;);
<a name="l00357"></a>00357   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">sizeof_databus</a> = sizeof_databus;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359   <span class="comment">// calculate new size:  nr stream words multiplied by big enough stream width</span>
<a name="l00360"></a>00360   <span class="keywordtype">int</span> s_width = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#8cc2025a351f5fa8cf3e91a03a089a81">get_streaming_width</a>();
<a name="l00361"></a>00361   <span class="keywordtype">int</span> length = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>();
<a name="l00362"></a>00362   <span class="keywordflow">if</span>(s_width &gt;= length) s_width = length;
<a name="l00363"></a>00363   <span class="keywordtype">int</span> nr_stream_words = length/s_width;
<a name="l00364"></a>00364 
<a name="l00365"></a>00365   <span class="comment">// find out in which bus word the stream word starts and ends</span>
<a name="l00366"></a>00366   sc_dt::uint64 new_address = (txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#56d9cf62de27f45e93a45bf5c144c288">get_address</a>() &amp; ~(sizeof_databus - 1));
<a name="l00367"></a>00367   sc_dt::uint64 end_address = ((txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#56d9cf62de27f45e93a45bf5c144c288">get_address</a>() + s_width - 1)
<a name="l00368"></a>00368     &amp; ~(sizeof_databus - 1));
<a name="l00369"></a>00369 
<a name="l00370"></a>00370   <span class="keywordtype">int</span> new_stream_width = end_address - new_address + sizeof_databus;
<a name="l00371"></a>00371   <span class="keywordtype">int</span> new_length = new_stream_width * nr_stream_words;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373   <span class="comment">// store context</span>
<a name="l00374"></a>00374   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a> = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>();
<a name="l00375"></a>00375   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a> = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#56d9cf62de27f45e93a45bf5c144c288">get_address</a>();
<a name="l00376"></a>00376   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#4b592ed6192127e7f2df6c810bbf1499">new_address</a> = new_address;
<a name="l00377"></a>00377   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#d43407778698362ee2f0b92b9b43394a">stream_width</a> = s_width;
<a name="l00378"></a>00378   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *orig_be = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>();
<a name="l00379"></a>00379   <span class="keywordtype">int</span> orig_be_length = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#76711646a3572d111dc6d80769e55158">get_byte_enable_length</a>();
<a name="l00380"></a>00380 
<a name="l00381"></a>00381   <span class="comment">// create data and byte-enable buffers</span>
<a name="l00382"></a>00382   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#486d7746584d058f148f6b3d6aab55c4">set_address</a>(new_address);
<a name="l00383"></a>00383   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#e667b8c79527e2ac2fe5355e1e5854d5">establish_dbuf</a>(new_length);
<a name="l00384"></a>00384   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#03a1359e212624b834b64ac4b36a82ba">set_data_ptr</a>(tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#881e78625efff381112316271f8c0baa">new_dbuf</a>);
<a name="l00385"></a>00385   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#e291fca8f514174828d9d17b3adbe4ba">establish_bebuf</a>(new_length);
<a name="l00386"></a>00386   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#ef1f7d2a2d743aaa304a85d361e880db">set_byte_enable_ptr</a>(tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#32ee9f4cae59221799c53558e01aff04">new_bebuf</a>);
<a name="l00387"></a>00387   memset(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>(), <a class="code" href="tlm__gp_8h.html#ee6c671fa7a49f01da4a966f33067175">TLM_BYTE_DISABLED</a>, new_length);
<a name="l00388"></a>00388   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#bdd0e57c84918a6a1796248e577979f7">set_streaming_width</a>(new_stream_width);
<a name="l00389"></a>00389   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#8bb2743225851e7d2e8d5c3f0213f379">set_data_length</a>(new_length);
<a name="l00390"></a>00390   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#465e5b08194660aa0b66d4e8219fa887">set_byte_enable_length</a>(new_length);
<a name="l00391"></a>00391 
<a name="l00392"></a>00392   <span class="comment">// copy data and/or byte enables</span>
<a name="l00393"></a>00393   <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#234bd44edb3ccb706b7ba030c3a2200d">is_write</a>()) {
<a name="l00394"></a>00394     <span class="keywordflow">if</span>(orig_be == 0) {
<a name="l00395"></a>00395       loop_generic0&lt;DATAWORD, &amp;copy_dbtrue0&gt;(new_length,
<a name="l00396"></a>00396         new_stream_width, s_width, sizeof_databus, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a>,
<a name="l00397"></a>00397         new_address, new_length, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>, 0, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>(),
<a name="l00398"></a>00398         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00399"></a>00399     } <span class="keywordflow">else</span> {
<a name="l00400"></a>00400       loop_generic0&lt;DATAWORD, &amp;copy_db0&gt;(new_length,
<a name="l00401"></a>00401         new_stream_width, s_width, sizeof_databus, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a>,
<a name="l00402"></a>00402         new_address, orig_be_length, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>, orig_be, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>(),
<a name="l00403"></a>00403         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00404"></a>00404     }
<a name="l00405"></a>00405   } <span class="keywordflow">else</span> { <span class="comment">// read transaction</span>
<a name="l00406"></a>00406     <span class="keywordflow">if</span>(orig_be == 0) {
<a name="l00407"></a>00407       loop_generic0&lt;DATAWORD, &amp;copy_btrue0&gt;(new_length,
<a name="l00408"></a>00408         new_stream_width, s_width, sizeof_databus, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a>,
<a name="l00409"></a>00409         new_address, new_length, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>, 0, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>(),
<a name="l00410"></a>00410         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00411"></a>00411     } <span class="keywordflow">else</span> {
<a name="l00412"></a>00412       loop_generic0&lt;DATAWORD, &amp;copy_b0&gt;(new_length,
<a name="l00413"></a>00413         new_stream_width, s_width, sizeof_databus, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a>,
<a name="l00414"></a>00414         new_address, orig_be_length, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>, orig_be, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>(),
<a name="l00415"></a>00415         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00416"></a>00416     }
<a name="l00417"></a>00417   }
<a name="l00418"></a>00418 }
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 
<a name="l00423"></a>00423 <span class="comment">// function set (1): Utilities</span>
<a name="l00424"></a>00424 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt;
<a name="l00425"></a><a class="code" href="namespacetlm.html#84cdb571cfc8732f851414f7d9bcd907">00425</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#84cdb571cfc8732f851414f7d9bcd907">copy_d1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00426"></a>00426   *((D *)dest1) = *((D *)src1);
<a name="l00427"></a>00427   *((D *)dest2) = <a class="code" href="classtlm_1_1tlm__bool.html">tlm_bool&lt;D&gt;::TLM_TRUE</a>;
<a name="l00428"></a>00428 }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt;
<a name="l00431"></a><a class="code" href="namespacetlm.html#c1f531b30e3457e23cf7390af89d177c">00431</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#c1f531b30e3457e23cf7390af89d177c">copy_db1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00432"></a>00432   *((D *)dest1) = *((D *)src1);
<a name="l00433"></a>00433   *((D *)dest2) = *((D *)src2);
<a name="l00434"></a>00434 }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt;
<a name="l00437"></a><a class="code" href="namespacetlm.html#62d5cdda8e34c8d294c8bddfad2b430d">00437</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#62d5cdda8e34c8d294c8bddfad2b430d">true_b1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00438"></a>00438   *((D *)dest2) = <a class="code" href="classtlm_1_1tlm__bool.html">tlm_bool&lt;D&gt;::TLM_TRUE</a>;
<a name="l00439"></a>00439 }
<a name="l00440"></a>00440 
<a name="l00441"></a>00441 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt;
<a name="l00442"></a><a class="code" href="namespacetlm.html#ce6bc65e046b4e4462fee34350600937">00442</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#ce6bc65e046b4e4462fee34350600937">copy_b1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00443"></a>00443   *((D *)dest2) = *((D *)src2);
<a name="l00444"></a>00444 }
<a name="l00445"></a>00445 
<a name="l00446"></a>00446 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt;
<a name="l00447"></a><a class="code" href="namespacetlm.html#857724d110a186851542ef0ed25bc988">00447</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#857724d110a186851542ef0ed25bc988">copy_dbyb1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00448"></a>00448   <span class="keywordflow">if</span>(*src2 != <a class="code" href="tlm__gp_8h.html#ee6c671fa7a49f01da4a966f33067175">TLM_BYTE_DISABLED</a>)  *((D *)src1) = *((D *)dest1);
<a name="l00449"></a>00449 }
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt;
<a name="l00452"></a><a class="code" href="namespacetlm.html#31284a38d814a73fadab6e4b7fd3f344">00452</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#31284a38d814a73fadab6e4b7fd3f344">copy_dbytrue1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2) {
<a name="l00453"></a>00453   *((D *)src1) = *((D *)dest1);
<a name="l00454"></a>00454 }
<a name="l00455"></a>00455 
<a name="l00456"></a><a class="code" href="namespacetlm.html#bb2f8a63e8e66eb796f69f99b31ddd2f">00456</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#bb2f8a63e8e66eb796f69f99b31ddd2f">false_b1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1) {
<a name="l00457"></a>00457   *((D *)dest1) = <a class="code" href="classtlm_1_1tlm__bool.html">tlm_bool&lt;D&gt;::TLM_FALSE</a>;
<a name="l00458"></a>00458 }
<a name="l00459"></a>00459 
<a name="l00460"></a><a class="code" href="namespacetlm.html#51f3cb6b05cbcb2a0f3fec8fa61bf620">00460</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#51f3cb6b05cbcb2a0f3fec8fa61bf620">no_b1</a>(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1) {
<a name="l00461"></a>00461 }
<a name="l00462"></a>00462 
<a name="l00463"></a>00463 <span class="keyword">template</span>&lt;<span class="keyword">class </span>D,
<a name="l00464"></a>00464          <span class="keywordtype">void</span> COPY(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2),
<a name="l00465"></a>00465          <span class="keywordtype">void</span> COPYuchar(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src2, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest2),
<a name="l00466"></a>00466          <span class="keywordtype">void</span> FILLFALSE(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1), <span class="keywordtype">void</span> FILLFALSEuchar(<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest1)&gt;
<a name="l00467"></a><a class="code" href="namespacetlm.html#2c4671fae3a52f0d9250c56535776cce">00467</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespacetlm.html#2c4671fae3a52f0d9250c56535776cce">loop_word1</a>(
<a name="l00468"></a>00468   <span class="keywordtype">int</span> bytes_left, <span class="keywordtype">int</span> len0, <span class="keywordtype">int</span> lenN, <span class="keywordtype">int</span> sizeof_databus,
<a name="l00469"></a>00469   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *start, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *end, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *src, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *bsrc, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *dest, <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *bdest) {
<a name="l00470"></a>00470   ptrdiff_t d2b_src = bsrc - src;  <span class="comment">// 64BITFIX was int //</span>
<a name="l00471"></a>00471   ptrdiff_t d2b_dest = bdest - dest;  <span class="comment">// 64BITFIX was int //</span>
<a name="l00472"></a>00472   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *original_dest = dest;
<a name="l00473"></a>00473 
<a name="l00474"></a>00474   <span class="keywordflow">while</span>(<span class="keyword">true</span>) {
<a name="l00475"></a>00475     <span class="comment">// len0 bytes at start of a bus word</span>
<a name="l00476"></a>00476     <span class="keywordflow">if</span>((src &gt;= start) &amp;&amp; (src &lt; end)) {
<a name="l00477"></a>00477       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;len0; i++) {
<a name="l00478"></a>00478         COPYuchar(src, src+d2b_src, dest, dest+d2b_dest);
<a name="l00479"></a>00479         src++;
<a name="l00480"></a>00480         dest++;
<a name="l00481"></a>00481       }
<a name="l00482"></a>00482       bytes_left -= len0;
<a name="l00483"></a>00483       <span class="keywordflow">if</span>(bytes_left &lt;= 0) <span class="keywordflow">return</span> int(dest - original_dest);
<a name="l00484"></a>00484     } <span class="keywordflow">else</span> {
<a name="l00485"></a>00485       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;len0; i++) {
<a name="l00486"></a>00486         FILLFALSEuchar(dest+d2b_dest);
<a name="l00487"></a>00487         src++;
<a name="l00488"></a>00488         dest++;
<a name="l00489"></a>00489       }
<a name="l00490"></a>00490     }
<a name="l00491"></a>00491     src -= 2 * <span class="keyword">sizeof</span>(D);
<a name="l00492"></a>00492 
<a name="l00493"></a>00493     <span class="comment">// sequence of full data word fragments</span>
<a name="l00494"></a>00494     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1; i&lt;sizeof_databus/<span class="keyword">sizeof</span>(D); i++) {
<a name="l00495"></a>00495       <span class="keywordflow">if</span>((src &gt;= start) &amp;&amp; (src &lt; end)) {
<a name="l00496"></a>00496         COPY(src, src+d2b_src, dest, dest+d2b_dest);
<a name="l00497"></a>00497         bytes_left -= <span class="keyword">sizeof</span>(D);
<a name="l00498"></a>00498       } <span class="keywordflow">else</span> {
<a name="l00499"></a>00499         FILLFALSE(dest+d2b_dest);
<a name="l00500"></a>00500       }
<a name="l00501"></a>00501       dest += <span class="keyword">sizeof</span>(D);
<a name="l00502"></a>00502       <span class="keywordflow">if</span>(bytes_left &lt;= 0) <span class="keywordflow">return</span> int(dest - original_dest);
<a name="l00503"></a>00503       src -= <span class="keyword">sizeof</span>(D);
<a name="l00504"></a>00504     }
<a name="l00505"></a>00505 
<a name="l00506"></a>00506     <span class="comment">// lenN bytes at end of bus word</span>
<a name="l00507"></a>00507     <span class="keywordflow">if</span>((src &gt;= start) &amp;&amp; (src &lt; end)) {
<a name="l00508"></a>00508       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;lenN; i++) {
<a name="l00509"></a>00509         COPYuchar(src, src+d2b_src, dest, dest+d2b_dest);
<a name="l00510"></a>00510         src++;
<a name="l00511"></a>00511         dest++;
<a name="l00512"></a>00512       }
<a name="l00513"></a>00513       bytes_left -= lenN;
<a name="l00514"></a>00514       <span class="keywordflow">if</span>(bytes_left &lt;= 0) <span class="keywordflow">return</span> int(dest - original_dest);
<a name="l00515"></a>00515     } <span class="keywordflow">else</span> {
<a name="l00516"></a>00516       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;lenN; i++) {
<a name="l00517"></a>00517         FILLFALSEuchar(dest+d2b_dest);
<a name="l00518"></a>00518         src++;
<a name="l00519"></a>00519         dest++;
<a name="l00520"></a>00520       }
<a name="l00521"></a>00521     }
<a name="l00522"></a>00522     src += 2 * sizeof_databus;
<a name="l00523"></a>00523   }
<a name="l00524"></a>00524 }
<a name="l00525"></a>00525 
<a name="l00526"></a>00526 
<a name="l00528"></a>00528 <span class="comment">// function set (1): Response</span>
<a name="l00529"></a>00529 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00530"></a><a class="code" href="namespacetlm.html#0c2303006c0d0a9434b765387180f6c2">00530</a> <a class="code" href="namespacetlm.html#0c2303006c0d0a9434b765387180f6c2">tlm_from_hostendian_word</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00531"></a>00531   <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#a99b26718e52fd5a49ab8475b44b8dac">is_read</a>()) {
<a name="l00532"></a>00532     <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = txn-&gt;template get_extension&lt;tlm_endian_context&gt;();
<a name="l00533"></a>00533     sc_dt::uint64 b_mask = sizeof_databus - 1;
<a name="l00534"></a>00534     <span class="keywordtype">int</span> d_mask = <span class="keyword">sizeof</span>(DATAWORD) - 1;
<a name="l00535"></a>00535     <span class="keywordtype">int</span> a_offset = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a> &amp; b_mask);
<a name="l00536"></a>00536     <span class="keywordtype">int</span> len0 = (sizeof_databus - a_offset) &amp; d_mask;
<a name="l00537"></a>00537     <span class="keywordtype">int</span> lenN = <span class="keyword">sizeof</span>(DATAWORD) - len0;
<a name="l00538"></a>00538     <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *d_start = tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>;
<a name="l00539"></a>00539     <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *d_end = ptrdiff_t(tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#caa2d690d4f526cbf6b39575033d717e">length</a>) + d_start;  <span class="comment">// 64BITFIX probably redundant //</span>
<a name="l00540"></a>00540     <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *d = ptrdiff_t(((sizeof_databus - a_offset) &amp; ~d_mask) + lenN) + d_start;  <span class="comment">// 64BITFIX probably redundant //</span>
<a name="l00541"></a>00541 
<a name="l00542"></a>00542     <span class="comment">// iterate over transaction copying data qualified by byte-enables</span>
<a name="l00543"></a>00543     <span class="keywordflow">if</span>(tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#e4a357d465b80c6c6b049e48a736d34b">byte_enable</a> == 0) {
<a name="l00544"></a>00544       loop_word1&lt;DATAWORD, &amp;copy_dbytrue1&lt;DATAWORD&gt;,
<a name="l00545"></a>00545         &amp;copy_dbytrue1&lt;uchar&gt;, &amp;no_b1&lt;DATAWORD&gt;, &amp;no_b1&lt;uchar&gt; &gt;(
<a name="l00546"></a>00546         tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#caa2d690d4f526cbf6b39575033d717e">length</a>, len0, lenN, sizeof_databus, d_start, d_end, d,
<a name="l00547"></a>00547         0, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>(), 0);
<a name="l00548"></a>00548     } <span class="keywordflow">else</span> {
<a name="l00549"></a>00549       loop_word1&lt;DATAWORD, &amp;copy_dbyb1&lt;DATAWORD&gt;,
<a name="l00550"></a>00550         &amp;copy_dbyb1&lt;uchar&gt;, &amp;no_b1&lt;DATAWORD&gt;, &amp;no_b1&lt;uchar&gt; &gt;(
<a name="l00551"></a>00551         tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#caa2d690d4f526cbf6b39575033d717e">length</a>, len0, lenN, sizeof_databus, d_start, d_end, d,
<a name="l00552"></a>00552         tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#e4a357d465b80c6c6b049e48a736d34b">byte_enable</a> - d_start + d, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>(), 0);
<a name="l00553"></a>00553     }
<a name="l00554"></a>00554   }
<a name="l00555"></a>00555 }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557 
<a name="l00559"></a>00559 <span class="comment">// function set (1): Request</span>
<a name="l00560"></a>00560 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00561"></a><a class="code" href="namespacetlm.html#35b6acc377c3fde9939342bf09d2a688">00561</a> <a class="code" href="namespacetlm.html#35b6acc377c3fde9939342bf09d2a688">tlm_to_hostendian_word</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00562"></a>00562   <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = <a class="code" href="namespacetlm.html#3d28c3714f7375334465f92755ed3e36">establish_context</a>(txn);
<a name="l00563"></a>00563   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#d6c5b6fb7e74f050d115825408688dab">from_f</a> = &amp;(tlm_from_hostendian_word&lt;DATAWORD&gt;);
<a name="l00564"></a>00564   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">sizeof_databus</a> = sizeof_databus;
<a name="l00565"></a>00565 
<a name="l00566"></a>00566   sc_dt::uint64 b_mask = sizeof_databus - 1;
<a name="l00567"></a>00567   <span class="keywordtype">int</span> d_mask = <span class="keyword">sizeof</span>(DATAWORD) - 1;
<a name="l00568"></a>00568   sc_dt::uint64 a_aligned = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#56d9cf62de27f45e93a45bf5c144c288">get_address</a>() &amp; ~b_mask;
<a name="l00569"></a>00569   <span class="keywordtype">int</span> a_offset = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#56d9cf62de27f45e93a45bf5c144c288">get_address</a>() &amp; b_mask);
<a name="l00570"></a>00570   <span class="keywordtype">int</span> len0 = (sizeof_databus - a_offset) &amp; d_mask;
<a name="l00571"></a>00571   <span class="keywordtype">int</span> lenN = <span class="keyword">sizeof</span>(DATAWORD) - len0;
<a name="l00572"></a>00572   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *d_start = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>();
<a name="l00573"></a>00573   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *d_end = ptrdiff_t(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>()) + d_start;  <span class="comment">// 64BITFIX probably redundant //</span>
<a name="l00574"></a>00574   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *d = ptrdiff_t(((sizeof_databus - a_offset) &amp; ~d_mask) + lenN) + d_start;  <span class="comment">// 64BITFIX probably redundant //</span>
<a name="l00575"></a>00575 
<a name="l00576"></a>00576   <span class="comment">// create new data and byte enable buffers</span>
<a name="l00577"></a>00577   <span class="keywordtype">int</span> long_enough = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>() + 2 * sizeof_databus;
<a name="l00578"></a>00578   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#e667b8c79527e2ac2fe5355e1e5854d5">establish_dbuf</a>(long_enough);
<a name="l00579"></a>00579   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *new_data = tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#881e78625efff381112316271f8c0baa">new_dbuf</a>;
<a name="l00580"></a>00580   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#e291fca8f514174828d9d17b3adbe4ba">establish_bebuf</a>(long_enough);
<a name="l00581"></a>00581   <a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *new_be = tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#32ee9f4cae59221799c53558e01aff04">new_bebuf</a>;
<a name="l00582"></a>00582 
<a name="l00583"></a>00583   <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#a99b26718e52fd5a49ab8475b44b8dac">is_read</a>()) {
<a name="l00584"></a>00584     tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a> = d_start;
<a name="l00585"></a>00585     tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#9bdc4824409e45580b25760be2270836">address</a> = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#56d9cf62de27f45e93a45bf5c144c288">get_address</a>();
<a name="l00586"></a>00586     tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#e4a357d465b80c6c6b049e48a736d34b">byte_enable</a> = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>();
<a name="l00587"></a>00587     tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#caa2d690d4f526cbf6b39575033d717e">length</a> = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>();
<a name="l00588"></a>00588     <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>() == 0) {
<a name="l00589"></a>00589       <span class="comment">// iterate over transaction creating new byte enables from all-true</span>
<a name="l00590"></a>00590       txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#8bb2743225851e7d2e8d5c3f0213f379">set_data_length</a>(<a class="code" href="namespacetlm.html#2c4671fae3a52f0d9250c56535776cce">loop_word1</a>&lt;DATAWORD, &amp;true_b1&lt;DATAWORD&gt;,
<a name="l00591"></a>00591         &amp;true_b1&lt;uchar&gt;, &amp;false_b1&lt;DATAWORD&gt;, &amp;false_b1&lt;uchar&gt; &gt;(
<a name="l00592"></a>00592         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>(), len0, lenN, sizeof_databus,
<a name="l00593"></a>00593         d_start, d_end, d, 0, new_data, new_be));
<a name="l00594"></a>00594     } <span class="keywordflow">else</span> {
<a name="l00595"></a>00595       <span class="comment">// iterate over transaction copying byte enables</span>
<a name="l00596"></a>00596       txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#8bb2743225851e7d2e8d5c3f0213f379">set_data_length</a>(<a class="code" href="namespacetlm.html#2c4671fae3a52f0d9250c56535776cce">loop_word1</a>&lt;DATAWORD, &amp;copy_b1&lt;DATAWORD&gt;,
<a name="l00597"></a>00597         &amp;copy_b1&lt;uchar&gt;, &amp;false_b1&lt;DATAWORD&gt;, &amp;false_b1&lt;uchar&gt; &gt;(
<a name="l00598"></a>00598         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>(), len0, lenN, sizeof_databus, d_start, d_end,
<a name="l00599"></a>00599         d, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>() - d_start + d, new_data, new_be));
<a name="l00600"></a>00600     }
<a name="l00601"></a>00601   } <span class="keywordflow">else</span> {
<a name="l00602"></a>00602     <span class="comment">// WRITE</span>
<a name="l00603"></a>00603     <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>() == 0) {
<a name="l00604"></a>00604       <span class="comment">// iterate over transaction copying data and creating new byte-enables</span>
<a name="l00605"></a>00605       txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#8bb2743225851e7d2e8d5c3f0213f379">set_data_length</a>(<a class="code" href="namespacetlm.html#2c4671fae3a52f0d9250c56535776cce">loop_word1</a>&lt;DATAWORD, &amp;copy_d1&lt;DATAWORD&gt;,
<a name="l00606"></a>00606         &amp;copy_d1&lt;uchar&gt;, &amp;false_b1&lt;DATAWORD&gt;, &amp;false_b1&lt;uchar&gt; &gt;(
<a name="l00607"></a>00607         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>(), len0, lenN, sizeof_databus,
<a name="l00608"></a>00608         d_start, d_end, d, 0, new_data, new_be));
<a name="l00609"></a>00609     } <span class="keywordflow">else</span> {
<a name="l00610"></a>00610       <span class="comment">// iterate over transaction copying data and byte-enables</span>
<a name="l00611"></a>00611       txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#8bb2743225851e7d2e8d5c3f0213f379">set_data_length</a>(<a class="code" href="namespacetlm.html#2c4671fae3a52f0d9250c56535776cce">loop_word1</a>&lt;DATAWORD, &amp;copy_db1&lt;DATAWORD&gt;,
<a name="l00612"></a>00612         &amp;copy_db1&lt;uchar&gt;, &amp;false_b1&lt;DATAWORD&gt;, &amp;false_b1&lt;uchar&gt; &gt;(
<a name="l00613"></a>00613         txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>(), len0, lenN, sizeof_databus, d_start, d_end,
<a name="l00614"></a>00614         d, txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>() - d_start + d, new_data, new_be));
<a name="l00615"></a>00615     }
<a name="l00616"></a>00616   }
<a name="l00617"></a>00617   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#465e5b08194660aa0b66d4e8219fa887">set_byte_enable_length</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>());
<a name="l00618"></a>00618   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#bdd0e57c84918a6a1796248e577979f7">set_streaming_width</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>());
<a name="l00619"></a>00619   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#03a1359e212624b834b64ac4b36a82ba">set_data_ptr</a>(new_data);
<a name="l00620"></a>00620   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#ef1f7d2a2d743aaa304a85d361e880db">set_byte_enable_ptr</a>(new_be);
<a name="l00621"></a>00621   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#486d7746584d058f148f6b3d6aab55c4">set_address</a>(a_aligned);
<a name="l00622"></a>00622 }
<a name="l00623"></a>00623 
<a name="l00624"></a>00624 
<a name="l00625"></a>00625 
<a name="l00627"></a>00627 <span class="comment">// function set (2): Utilities</span>
<a name="l00628"></a><a class="code" href="namespacetlm.html#5999c6d18647908c0e26d0f9904dc748">00628</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#5999c6d18647908c0e26d0f9904dc748">copy_d2</a>(D *src1, D *src2, D *dest1, D *dest2) {
<a name="l00629"></a>00629   *dest1 = *src1;
<a name="l00630"></a>00630 }
<a name="l00631"></a>00631 
<a name="l00632"></a><a class="code" href="namespacetlm.html#8cbc0c1ac45d4daae88569377c49b76e">00632</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#8cbc0c1ac45d4daae88569377c49b76e">copy_db2</a>(D *src1, D *src2, D *dest1, D *dest2) {
<a name="l00633"></a>00633   *dest1 = *src1;
<a name="l00634"></a>00634   *dest2 = *src2;
<a name="l00635"></a>00635 }
<a name="l00636"></a>00636 
<a name="l00637"></a>00637 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D&gt;
<a name="l00638"></a><a class="code" href="namespacetlm.html#42e626507b6d547e498f97833c4c4a1c">00638</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#42e626507b6d547e498f97833c4c4a1c">copy_dbyb2</a>(D *src1, D *src2, D *dest1, D *dest2) {
<a name="l00639"></a>00639   <span class="keywordflow">if</span>(<a class="code" href="classtlm_1_1tlm__bool.html">tlm_bool&lt;D&gt;</a>(*src2)) *dest1 = *src1;
<a name="l00640"></a>00640 }
<a name="l00641"></a>00641 
<a name="l00642"></a>00642 <span class="keyword">template</span>&lt;<span class="keyword">class</span> D, <span class="keywordtype">void</span> COPY(D *src1, D *src2, D *dest1, D *dest2)&gt;
<a name="l00643"></a><a class="code" href="namespacetlm.html#8683423851f1e7bc2e4b4c7432e139c6">00643</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#8683423851f1e7bc2e4b4c7432e139c6">loop_aligned2</a>(D *src1, D *src2, D *dest1, D *dest2,
<a name="l00644"></a>00644     <span class="keywordtype">int</span> words, <span class="keywordtype">int</span> words_per_bus) {
<a name="l00645"></a>00645   ptrdiff_t src1to2 = (<span class="keywordtype">char</span> *)src2 - (<span class="keywordtype">char</span> *)src1;  <span class="comment">// 64BITFIX was int and operands were cast to int //</span>
<a name="l00646"></a>00646   ptrdiff_t dest1to2 = (<span class="keywordtype">char</span> *)dest2 - (<span class="keywordtype">char</span> *)dest1;  <span class="comment">// 64BITFIX was int and operands were cast to int //</span>
<a name="l00647"></a>00647 
<a name="l00648"></a>00648   D *done = src1 + ptrdiff_t(words);  <span class="comment">// 64BITFIX //</span>
<a name="l00649"></a>00649   D *bus_start = src1;
<a name="l00650"></a>00650   src1 += ptrdiff_t(words_per_bus - 1);  <span class="comment">// 64BITFIX //</span>
<a name="l00651"></a>00651 
<a name="l00652"></a>00652   <span class="keywordflow">while</span>(<span class="keyword">true</span>) {
<a name="l00653"></a>00653     COPY(src1, (D *)(src1to2+(<span class="keywordtype">char</span> *)src1), dest1, (D *)(dest1to2+(<span class="keywordtype">char</span> *)dest1));   <span class="comment">// 64BITFIX //</span>
<a name="l00654"></a>00654     dest1++;
<a name="l00655"></a>00655     <span class="keywordflow">if</span>((--src1) &lt; bus_start) {
<a name="l00656"></a>00656       bus_start += ptrdiff_t(words_per_bus);  <span class="comment">// 64BITFIX //</span>
<a name="l00657"></a>00657       <span class="keywordflow">if</span>(bus_start == done) <span class="keywordflow">break</span>;
<a name="l00658"></a>00658       src1 = bus_start + ptrdiff_t(words_per_bus - 1);  <span class="comment">// 64BITFIX //</span>
<a name="l00659"></a>00659     }
<a name="l00660"></a>00660   }
<a name="l00661"></a>00661 }
<a name="l00662"></a>00662 
<a name="l00663"></a>00663 
<a name="l00665"></a>00665 <span class="comment">// function set (2): Response</span>
<a name="l00666"></a>00666 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00667"></a><a class="code" href="namespacetlm.html#90c3a9a3b2afd67bc8e174172e074e18">00667</a> <a class="code" href="namespacetlm.html#90c3a9a3b2afd67bc8e174172e074e18">tlm_from_hostendian_aligned</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00668"></a>00668   <span class="keywordtype">int</span> words_per_bus = sizeof_databus/<span class="keyword">sizeof</span>(DATAWORD);
<a name="l00669"></a>00669   <span class="keywordflow">if</span>(words_per_bus == 1) <span class="keywordflow">return</span>;
<a name="l00670"></a>00670   <span class="keywordtype">int</span> words = (txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>())/<span class="keyword">sizeof</span>(DATAWORD);
<a name="l00671"></a>00671   <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = txn-&gt;template get_extension&lt;tlm_endian_context&gt;();
<a name="l00672"></a>00672 
<a name="l00673"></a>00673   <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>() == 0) {
<a name="l00674"></a>00674     <span class="comment">// no byte enables</span>
<a name="l00675"></a>00675     <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#a99b26718e52fd5a49ab8475b44b8dac">is_read</a>()) {
<a name="l00676"></a>00676       <span class="comment">// RD without byte enables.  Copy data to original buffer</span>
<a name="l00677"></a>00677       loop_aligned2&lt;DATAWORD, &amp;copy_d2&lt;DATAWORD&gt; &gt;(
<a name="l00678"></a>00678         (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>()),
<a name="l00679"></a>00679         0, (DATAWORD *)(tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>), 0, words, words_per_bus);
<a name="l00680"></a>00680     }
<a name="l00681"></a>00681   } <span class="keywordflow">else</span> {
<a name="l00682"></a>00682     <span class="comment">// byte enables present</span>
<a name="l00683"></a>00683     <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#a99b26718e52fd5a49ab8475b44b8dac">is_read</a>()) {
<a name="l00684"></a>00684       <span class="comment">// RD with byte enables.  Copy data qualified by byte-enables</span>
<a name="l00685"></a>00685       loop_aligned2&lt;DATAWORD, &amp;copy_dbyb2&lt;DATAWORD&gt; &gt;(
<a name="l00686"></a>00686         (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>()),
<a name="l00687"></a>00687         (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>()),
<a name="l00688"></a>00688         (DATAWORD *)(tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a>), 0, words, words_per_bus);
<a name="l00689"></a>00689     }
<a name="l00690"></a>00690   }
<a name="l00691"></a>00691 }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 
<a name="l00695"></a>00695 <span class="comment">// function set (2): Request</span>
<a name="l00696"></a>00696 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00697"></a><a class="code" href="namespacetlm.html#a097d494385217cb589f046dc0adf62d">00697</a> <a class="code" href="namespacetlm.html#a097d494385217cb589f046dc0adf62d">tlm_to_hostendian_aligned</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00698"></a>00698   <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = <a class="code" href="namespacetlm.html#3d28c3714f7375334465f92755ed3e36">establish_context</a>(txn);
<a name="l00699"></a>00699   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#d6c5b6fb7e74f050d115825408688dab">from_f</a> = &amp;(tlm_from_hostendian_aligned&lt;DATAWORD&gt;);
<a name="l00700"></a>00700   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">sizeof_databus</a> = sizeof_databus;
<a name="l00701"></a>00701 
<a name="l00702"></a>00702   <span class="keywordtype">int</span> words_per_bus = sizeof_databus/<span class="keyword">sizeof</span>(DATAWORD);
<a name="l00703"></a>00703   <span class="keywordflow">if</span>(words_per_bus == 1) <span class="keywordflow">return</span>;
<a name="l00704"></a>00704   <span class="keywordtype">int</span> words = (txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>())/<span class="keyword">sizeof</span>(DATAWORD);
<a name="l00705"></a>00705 
<a name="l00706"></a>00706   DATAWORD *original_be = (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>());
<a name="l00707"></a>00707   DATAWORD *original_data = (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>());
<a name="l00708"></a>00708 
<a name="l00709"></a>00709   <span class="comment">// always allocate a new data buffer</span>
<a name="l00710"></a>00710   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#e667b8c79527e2ac2fe5355e1e5854d5">establish_dbuf</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>());
<a name="l00711"></a>00711   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#03a1359e212624b834b64ac4b36a82ba">set_data_ptr</a>(tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#881e78625efff381112316271f8c0baa">new_dbuf</a>);
<a name="l00712"></a>00712 
<a name="l00713"></a>00713   <span class="keywordflow">if</span>(original_be == 0) {
<a name="l00714"></a>00714     <span class="comment">// no byte enables</span>
<a name="l00715"></a>00715     <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#234bd44edb3ccb706b7ba030c3a2200d">is_write</a>()) {
<a name="l00716"></a>00716       <span class="comment">// WR no byte enables.  Copy data</span>
<a name="l00717"></a>00717       loop_aligned2&lt;DATAWORD, &amp;copy_d2&lt;DATAWORD&gt; &gt;(original_data, 0,
<a name="l00718"></a>00718         (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>()), 0,
<a name="l00719"></a>00719         words, words_per_bus);
<a name="l00720"></a>00720     } <span class="keywordflow">else</span> {
<a name="l00721"></a>00721       <span class="comment">// RD no byte enables.  Save original data pointer</span>
<a name="l00722"></a>00722       tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a> = (<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)original_data;
<a name="l00723"></a>00723     }
<a name="l00724"></a>00724   } <span class="keywordflow">else</span> {
<a name="l00725"></a>00725     <span class="comment">// byte enables present</span>
<a name="l00726"></a>00726     <span class="comment">// allocate a new buffer for them</span>
<a name="l00727"></a>00727     tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#e291fca8f514174828d9d17b3adbe4ba">establish_bebuf</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>());
<a name="l00728"></a>00728     txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#ef1f7d2a2d743aaa304a85d361e880db">set_byte_enable_ptr</a>(tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#32ee9f4cae59221799c53558e01aff04">new_bebuf</a>);
<a name="l00729"></a>00729     txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#465e5b08194660aa0b66d4e8219fa887">set_byte_enable_length</a>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#e1e9ec21a8dddd5fbf612d41814f54d7">get_data_length</a>());
<a name="l00730"></a>00730 
<a name="l00731"></a>00731     <span class="keywordflow">if</span>(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#234bd44edb3ccb706b7ba030c3a2200d">is_write</a>()) {
<a name="l00732"></a>00732       <span class="comment">// WR with byte enables.  Copy data and BEs</span>
<a name="l00733"></a>00733       loop_aligned2&lt;DATAWORD, &amp;copy_db2&lt;DATAWORD&gt; &gt;(original_data, original_be,
<a name="l00734"></a>00734         (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#195859527e5438cd8260d28eef1eb076">get_data_ptr</a>()),
<a name="l00735"></a>00735         (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>()), words, words_per_bus);
<a name="l00736"></a>00736     } <span class="keywordflow">else</span> {
<a name="l00737"></a>00737       <span class="comment">// RD with byte enables.  Save original data pointer</span>
<a name="l00738"></a>00738       tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#73fa2084a54be6b76aabc6f36ecbf6d1">data_ptr</a> = (<a class="code" href="tlm__endian__conv_8h.html#a8ddf20cdd716b652e76e23e5e700893">uchar</a> *)original_data;
<a name="l00739"></a>00739       <span class="comment">// Copy byte enables to new buffer</span>
<a name="l00740"></a>00740       loop_aligned2&lt;DATAWORD, &amp;copy_d2&lt;DATAWORD&gt; &gt;(original_be, 0,
<a name="l00741"></a>00741         (DATAWORD *)(txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#38b031e6dcbb51db9f368b494c4ff091">get_byte_enable_ptr</a>()), 0,
<a name="l00742"></a>00742         words, words_per_bus);
<a name="l00743"></a>00743     }
<a name="l00744"></a>00744   }
<a name="l00745"></a>00745 }
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 
<a name="l00748"></a>00748 
<a name="l00750"></a>00750 <span class="comment">// function set (3): Response</span>
<a name="l00751"></a>00751 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00752"></a><a class="code" href="namespacetlm.html#2c263fbf6cf9755d9f6eeca09dd23838">00752</a> <a class="code" href="namespacetlm.html#2c263fbf6cf9755d9f6eeca09dd23838">tlm_from_hostendian_single</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00753"></a>00753   <span class="comment">// nothing needs to be done here</span>
<a name="l00754"></a>00754 }
<a name="l00755"></a>00755 
<a name="l00756"></a>00756 
<a name="l00758"></a>00758 <span class="comment">// function set (3): Request</span>
<a name="l00759"></a>00759 <span class="keyword">template</span>&lt;<span class="keyword">class</span> DATAWORD&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00760"></a><a class="code" href="namespacetlm.html#a0b3eb97d390a24dd271eea549885fdf">00760</a> <a class="code" href="namespacetlm.html#a0b3eb97d390a24dd271eea549885fdf">tlm_to_hostendian_single</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeof_databus) {
<a name="l00761"></a>00761   <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = <a class="code" href="namespacetlm.html#3d28c3714f7375334465f92755ed3e36">establish_context</a>(txn);
<a name="l00762"></a>00762   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#d6c5b6fb7e74f050d115825408688dab">from_f</a> = &amp;(tlm_from_hostendian_single&lt;DATAWORD&gt;);
<a name="l00763"></a>00763   tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">sizeof_databus</a> = sizeof_databus;
<a name="l00764"></a>00764 
<a name="l00765"></a>00765   <span class="comment">// only need to change the address, always safe to work in-place</span>
<a name="l00766"></a>00766   sc_dt::uint64 mask = sizeof_databus-1;
<a name="l00767"></a>00767   sc_dt::uint64 a = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#56d9cf62de27f45e93a45bf5c144c288">get_address</a>();
<a name="l00768"></a>00768   txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#486d7746584d058f148f6b3d6aab55c4">set_address</a>((a &amp; ~mask) |
<a name="l00769"></a>00769     (sizeof_databus - (a &amp; mask) - <span class="keyword">sizeof</span>(DATAWORD)));
<a name="l00770"></a>00770 }
<a name="l00771"></a>00771 
<a name="l00772"></a>00772 
<a name="l00773"></a>00773 
<a name="l00775"></a>00775 <span class="comment">// helper function which works for all responses</span>
<a name="l00776"></a><a class="code" href="namespacetlm.html#7089b671b64863a5d1f59b8b5c9f648f">00776</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacetlm.html#7089b671b64863a5d1f59b8b5c9f648f">tlm_from_hostendian</a>(<a class="code" href="classtlm_1_1tlm__generic__payload.html">tlm_generic_payload</a> *txn) {
<a name="l00777"></a>00777   <a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a> *tc = txn-&gt;<a class="code" href="classtlm_1_1tlm__generic__payload.html#57e1f088841057cd1c2717701c240396">get_extension</a>&lt;<a class="code" href="classtlm_1_1tlm__endian__context.html">tlm_endian_context</a>&gt;();
<a name="l00778"></a>00778   (*(tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#d6c5b6fb7e74f050d115825408688dab">from_f</a>))(txn, tc-&gt;<a class="code" href="classtlm_1_1tlm__endian__context.html#ddd9342d542c433f48b7b19af829bb43">sizeof_databus</a>);
<a name="l00779"></a>00779 }
<a name="l00780"></a>00780 
<a name="l00781"></a>00781 
<a name="l00782"></a>00782 <span class="preprocessor">#ifndef TLM_END_CONV_DONT_UNDEF_UCHAR</span>
<a name="l00783"></a>00783 <span class="preprocessor"></span><span class="preprocessor">#undef uchar</span>
<a name="l00784"></a>00784 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00785"></a>00785 <span class="preprocessor"></span>
<a name="l00786"></a>00786 }  <span class="comment">// namespace tlm</span>
<a name="l00787"></a>00787 
<a name="l00788"></a>00788 
<a name="l00789"></a>00789 <span class="preprocessor">#endif  // multiple-inclusion protection</span>
<a name="l00790"></a>00790 <span class="preprocessor"></span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Jul 15 13:46:49 2009 for TLM-2.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
